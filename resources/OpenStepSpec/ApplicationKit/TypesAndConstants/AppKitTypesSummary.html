<html><head><TITLE>AppKitTypesSummary.html</TITLE><!-- This document was created from RTF source by rtftohtml version
2.7.4 --></head><body><A HREF="../../OpenStepSpec.html">Return to Contents</A><HR>
Copyright (c) 1994 by NeXT Computer, Inc.  All Rights
Reserved.<p>
<p>

<b>Types and Constants</b><p>

<hr>
<b>Application</b><p>

<b></b>id <b>NSApp</b>;
<p>
Represents the application's NSApplication object.
<p>
typedef struct _NSModalSession *<b>NSModalSession</b>;
<p>
This structure stores information used by the system during a modal session.<p>
<p>
Predefined return values for <b>runModalFor:</b> and <b>runModalSession:</b>.<p>
enum {
<UL>
<LI><b>NSRunStoppedResponse</b>,</LI>	
<LI><b>NSRunAbortedResponse</b>,</LI>
<LI><b>NSRunContinuesResponse</b></LI>
</UL>};<p>
<p>
NSString *<b>NSModalPanelRunLoopMode</b>;	Input-filter modes passed to
NSRunLoop.<p>
<p>
NSString *<b>NSEventTrackingRunLoopMode</b>;<p>

<hr>
<b>Box</b><p>

<b></b>typedef enum _NSTitlePosition {	This type's constants represent the
locations where an<p>
<b>NSNoTitle</b>,		NSBox's title is placed in relation to the border <p>
<b>NSAboveTop</b>,		(<b>setTitlePosition:</b> and <b>titlePosition</b>).<p>
<b>NSAtTop</b>,<p>
<b>NSBelowTop</b>,<p>
<b>NSAboveBottom</b>,<p>
<b>NSAtBottom</b>,<p>
<b>NSBelowBottom</b><p>
<b></b>} <b>NSTitlePosition</b>;<p>

<hr>
<b>Buttons</b><p>

<b></b>typedef enum _NSButtonType {	The constants of <b>NSButtonType</b>
indicate the way<p>
<b>NSMomentaryPushButton</b>, 		NSButtons and NSButtonCells behave when <p>
<b>NSPushOnPushOffButton</b>, 		pressed, and how they display their state. They
are<p>
<b>NSToggleButton</b>,  		used in NSButton's <b>setType:</b> method.<p>
<b>NSSwitchButton</b>,  <p>
<b>NSRadioButton</b>,  <p>
<b>NSMomentaryChangeButton</b>, <p>
<b>NSOnOffButton</b> <p>
} <b>NSButtonType</b>;<p>

<hr>
<b>Cells and Button Cells</b><p>

<b></b>typedef enum _NSCellType {	Represent different types of NSCell
objects.<p>
<b>NSNullCellType</b>, 		No display.<p>
<b>NSTextCellType</b>,		Displays text.<p>
<b>NSImageCellType</b>		Displays an image.<p>
} <b>NSCellType</b>;		Returned from <b>type</b> and set via <b>setType:</b>. <p>
<p>
typedef enum _NSCellImagePosition {	Represent the position of an NSButtonCell
relative to its <p>
<b>NSNoImage</b>,		title. Returned from <b>imagePosition</b> and set through<p>
<b>NSImageOnly</b>,		<b>setImagePosition:</b>.<p>
<b>NSImageLeft</b>,<p>
<b>NSImageRight</b>,   <p>
<b>NSImageBelow</b>,   <p>
<b>NSImageAbove</b>,   <p>
<b>NSImageOverlaps</b>  <p>
} <b>NSCellImagePosition</b>;<p>
<p>
typedef enum _NSCellAttribute {	The constant values of <b>NSCellAttribute</b>
represent <p>
<b>NSCellDisabled</b>,		parameters that you can set and access through<p>
<b>NSCellState</b>,		NSCell's and NSButtonCell's <b>setParameter:to:</b> and<p>
<b>NSPushInCell</b>,   		<b>getParameter:</b> methods. Only the first five
constants<p>
<b>NSCellEditable</b>,   		are used by NSCell; the others apply to
NSButtonCells<p>
<b>NSChangeGrayCell</b>,   		only.<p>
<b>NSCellHighlighted</b>,   <p>
<b>NSCellLightsByContents</b>,  <p>
<b>NSCellLightsByGray,</b>   <p>
<b>NSChangeBackgroundCell</b>,  <p>
<b>NSCellLightsByBackground</b>,  <p>
<b>NSCellIsBordered</b>,  <p>
<b>NSCellHasOverlappingImage</b>,  <p>
<b>NSCellHasImageHorizontal</b>,  <p>
<b>NSCellHasImageOnLeftOrBottom</b>, <p>
<b>NSCellChangesContents</b>,  <p>
<b>NSCellIsInsetButton</b><p>
<b></b>} <b>NSCellAttribute</b>;<p>
<p>
enum {	Numeric data types that an NSCell can accept. Used as <p>
<b>NSAnyType</b>,		the argument for <b>setEntryType:</b>.<p>
<b>NSIntType</b>,<p>
<b>NSPositiveIntType</b>,   <p>
<b>NSFloatType</b>,<p>
<b>NSPositiveFloatType</b>,   <p>
<b>NSDateType</b>,<p>
<b>NSDoubleType</b>,   <p>
<b>NSPositiveDoubleType</b><p>
<b></b>};<p>
<p>
enum {	NSButtonCell uses these values to determine how to <p>
<b>NSNoCellMask</b>,   		highlight a button cell or show an ON state <p>
<b>NSContentsCellMask</b>,		(returned/passed in<b>
showsStateBy</b>/<b>setShowsStateBy</b> <p>
<b>NSPushInCellMask</b>,   		and <b>highlightsBy</b>/<b>setHighlightsBy</b>).<p>
<b>NSChangeGrayCellMask</b>,  <p>
<b>NSChangeBackgroundCellMask</b><p>
<b></b>};<p>

<hr>
<b>Color</b><p>

<b></b>enum {	Tags that identify modes (or views) in the color panel.<p>
<b>NSGrayModeColorPanel</b>,<p>
<b>NSRGBModeColorPanel</b>,<p>
<b>NSCMYKModeColorPanel</b>,<p>
<b>NSHSBModeColorPanel</b>,<p>
<b>NSCustomPaletteModeColorPanel</b>,<p>
<b>NSColorListModeColorPanel</b>,<p>
<b>NSWheelModeColorPanel</b> <p>
};<p>
<p>
enum {	Bit masks for determining the current mode (or view) of the <p>
<b>NSColorPanelGrayModeMask</b>,		color panel.<p>
<b>NSColorPanelRGBModeMask</b>,<p>
<b>NSColorPanelCMYKModeMask</b>,<p>
<b>NSColorPanelHSBModeMask</b>,<p>
<b>NSColorPanelCustomPaletteModeMask</b>,<p>
<b>NSColorPanelColorListModeMask</b>,<p>
<b>NSColorPanelWheelModeMask</b>,<p>
<b>NSColorPanelAllModesMask</b>  <p>
};<p>

<hr>
<b>Data Link</b><p>

<b></b>typedef int <b>NSDataLinkNumber</b>;	Returned by NSDataLink's
<b>linkNumber</b> method as a persistent identifier of a destination link.<p>
<p>
NSString *<b>NSDataLinkFileNameExtension</b>;	The file name suffix to be used
when data links are saved. The default is <b>objlink</b>.<p>
<p>
typedef enum _NSDataLinkDisposition {	Returned by NSDataLink's
<b>disposition</b> method to identify<p>
 <b>NSLinkInDestination</b>,		a link as a destination link, a source link, or a
broken<p>
 <b>NSLinkInSource</b>,		link.<p>
 <b>NSLinkBroken</b> <p>
} <b>NSDataLinkDisposition</b>;<p>
<p>
typedef enum _NSDataLinkUpdateMode {	Identifies when a link's data is to be
updated. Set through<p>
 <b>NSUpdateContinuously</b>,		the <b>setUpdateMode:</b> method and returned by
<p>
 <b>NSUpdateWhenSourceSaved</b>,		<b>updateMode</b>.<p>
 <b>NSUpdateManually</b>,<p>
 <b>NSUpdateNever</b><p>
<b></b>} <b>NSDataLinkUpdateMode</b>;<p>
<p>

<hr>
<b>Drag Operation</b><p>

<b></b>typedef enum _NSDragOperation {	The constants of this type identify
different kinds of <p>
<b>NSDragOperationNone</b>,		dragging operations. <b>NSDragOperationNone</b>
implies <p>
<b>NSDragOperationCopy</b>,		that the operation is rejected. <p>
<b>NSDragOperationLink</b>,		<b>NSDragOperationPrivate </b>means that the
system <p>
<b>NSDragOperationGeneric</b>,		leaves the cursor alone.<p>
<b>NSDragOperationPrivate</b>,<p>
<b>NSDragOperationAll</b>   <p>
} <b>NSDragOperation</b>;<p>

<hr>
<b>Event Handling</b><p>

<b></b>typedef enum _NSEventType {	Each constant of <b>NSEventType</b>
identifies an event type.<p>
<b>NSLeftMouseDown</b>,		(See the NSEvent class description.)<p>
<b>NSLeftMouseUp</b>,<p>
<b>NSRightMouseDown</b>,<p>
<b>NSRightMouseUp</b>,<p>
<b>NSMouseMoved</b>,<p>
<b>NSLeftMouseDragged</b>,<p>
<b>NSRightMouseDragged</b>,<p>
<b>NSMouseEntered</b>,<p>
<b>NSMouseExited</b>,<p>
<b>NSKeyDown</b>,<p>
<b>NSKeyUp</b>,<p>
<b>NSFlagsChanged</b>,<p>
<b>NSPeriodic</b>,<p>
<b>NSCursorUpdate</b><p>
<b></b>} <b>NSEventType</b>;<p>
<p>
enum {	Unicodes that identify function keys on the keyboard,<p>
<b>NSUpArrowFunctionKey</b> = 0xF700,		OpenStep reserves the range
0xF700-0xF8FF for<p>
<b>NSDownArrowFunctionKey</b> = 0xF701,		this purpose. The availability of some
keys is<p>
<b>NSLeftArrowFunctionKey</b> = 0xF702,		system-dependent.<p>
<b>NSRightArrowFunctionKey</b> = 0xF703,<p>
<b>NSF1FunctionKey</b>  = 0xF704,<p>
<b>NSF2FunctionKey</b>  = 0xF705,<p>
<b>NSF3FunctionKey</b>  = 0xF706,<p>
<b>NSF4FunctionKey</b>  = 0xF707,<p>
<b>NSF5FunctionKey</b>  = 0xF708,<p>
<b>NSF6FunctionKey</b>  = 0xF709,<p>
<b>NSF7FunctionKey</b>  = 0xF70A,<p>
<b>NSF8FunctionKey</b>  = 0xF70B,<p>
<b>NSF9FunctionKey</b>  = 0xF70C,<p>
<b>NSF10FunctionKey</b> = 0xF70D,<p>
<b>NSF11FunctionKey</b> = 0xF70E,<p>
<b>NSF12FunctionKey</b> = 0xF70F,<p>
<b>NSF13FunctionKey</b> = 0xF710,<p>
<b>NSF14FunctionKey</b> = 0xF711,<p>
<b>NSF15FunctionKey</b> = 0xF712,<p>
<b>NSF16FunctionKey</b> = 0xF713,<p>
<b>NSF17FunctionKey</b> = 0xF714,<p>
<b>NSF18FunctionKey</b> = 0xF715,<p>
<b>NSF19FunctionKey</b> = 0xF716,<p>
<b>NSF20FunctionKey</b> = 0xF717,<p>
<b>NSF21FunctionKey</b> = 0xF718,<p>
<b>NSF22FunctionKey</b> = 0xF719,<p>
<b>NSF23FunctionKey</b> = 0xF71A,<p>
<b>NSF24FunctionKey</b> = 0xF71B,<p>
<b>NSF25FunctionKey</b> = 0xF71C,<p>
<b>NSF26FunctionKey</b> = 0xF71D,<p>
<b>NSF27FunctionKey</b> = 0xF71E,<p>
<b>NSF28FunctionKey</b> = 0xF71F,<p>
<b>NSF29FunctionKey</b> = 0xF720,<p>
<b>NSF30FunctionKey</b> = 0xF721,<p>
<b>NSF31FunctionKey</b> = 0xF722,<p>
<b>NSF32FunctionKey</b> = 0xF723,<p>
<b>NSF33FunctionKey</b> = 0xF724,<p>
<b>NSF34FunctionKey</b> = 0xF725,<p>
<b>NSF35FunctionKey</b> = 0xF726,<p>
<b>NSInsertFunctionKey</b> = 0xF727,<p>
<b>NSDeleteFunctionKey</b> = 0xF728,<p>
<b>NSHomeFunctionKey</b> = 0xF729,<p>
<b>NSBeginFunctionKey</b> = 0xF72A,<p>
<b>NSEndFunctionKey</b> = 0xF72B,<p>
<b>NSPageUpFunctionKey</b> = 0xF72C,<p>
<b>NSPageDownFunctionKey</b> = 0xF72D,<p>
<b>NSPrintScreenFunctionKey</b> = 0xF72E,<p>
<b>NSScrollLockFunctionKey</b> = 0xF72F,<p>
<b>NSPauseFunctionKey</b> = 0xF730,<p>
<b>NSSysReqFunctionKey</b> = 0xF731,<p>
<b>NSBreakFunctionKey</b> = 0xF732,<p>
<b>NSResetFunctionKey</b> = 0xF733,<p>
<b>NSStopFunctionKey</b> = 0xF734,<p>
<b>NSMenuFunctionKey</b> = 0xF735,<p>
<b>NSUserFunctionKey</b> = 0xF736,<p>
<b>NSSystemFunctionKey</b> = 0xF737,<p>
<b>NSPrintFunctionKey</b> = 0xF738,<p>
<b>NSClearLineFunctionKey</b> = 0xF739,<p>
<b>NSClearDisplayFunctionKey</b> = 0xF73A,<p>
<b>NSInsertLineFunctionKey</b> = 0xF73B,<p>
<b>NSDeleteLineFunctionKey</b> = 0xF73C,<p>
<b>NSInsertCharFunctionKey</b> = 0xF73D,<p>
<b>NSDeleteCharFunctionKey</b> = 0xF73E,<p>
<b>NSPrevFunctionKey</b> = 0xF73F,<p>
<b>NSNextFunctionKey</b> = 0xF740,<p>
<b>NSSelectFunctionKey</b> = 0xF741,<p>
<b>NSExecuteFunctionKey</b> = 0xF742,<p>
<b>NSUndoFunctionKey</b> = 0xF743,<p>
<b>NSRedoFunctionKey</b> = 0xF744,<p>
<b>NSFindFunctionKey</b> = 0xF745,<p>
<b>NSHelpFunctionKey</b> = 0xF746,<p>
<b>NSModeSwitchFunctionKey</b> = 0xF747<p>
};<p>
<p>
enum {	Device-independent bit masks for evaluating event- <p>
<b>NSAlphaShiftKeyMask</b>,		 modifier flags to determine which modifier key
(if any) <p>
<b>NSShiftKeyMask</b>,		was pressed.<p>
<b>NSControlKeyMask</b>,<p>
<b>NSAlternateKeyMask</b>,<p>
<b>NSCommandKeyMask</b>,<p>
<b>NSNumericPadKeyMask</b>,<p>
<b>NSHelpKeyMask</b>,<p>
<b>NSFunctionKeyMask</b><p>
<b></b>};<p>
<p>
enum {	Bit masks for determining the type of events.<p>
<b>NSLeftMouseDownMask</b>,<p>
<b>NSLeftMouseUpMask</b>,<p>
<b>NSRightMouseDownMask</b>,<p>
<b>NSRightMouseUpMask</b>,<p>
<b>NSMouseMovedMask</b>,<p>
<b>NSLeftMouseDraggedMask</b>,<p>
<b>NSRightMouseDraggedMask</b>,<p>
<b>NSMouseEnteredMask</b>,<p>
<b>NSMouseExitedMask</b>,<p>
<b>NSKeyDownMask</b>,<p>
<b>NSKeyUpMask</b>,<p>
<b>NSFlagsChangedMask</b>,<p>
<b>NSPeriodicMask</b>,<p>
<b>NSCursorUpdateMask</b>,<p>
<b>NSAnyEventMask</b>   <p>
};<p>

<hr>
<b>Exceptions</b><p>


<b>Global Exception Strings </b><p>


The following global strings identify the exceptions returned by various
operations in the Application Kit. They are defined in NSErrors.h.<p>
<p>
NSString *<b>NSAbortModalException</b>;<p>
<p>
NSString *<b>NSAbortPrintingException</b>;<p>
<p>
NSString *<b>NSAppKitIgnoredException</b>;<p>
<p>
NSString *<b>NSAppKitVirtualMemoryException</b>;<p>
<p>
NSString *<b>NSBadBitmapParametersException</b>;<p>
<p>
NSString *<b>NSBadComparisonException</b>;<p>
<p>
NSString *<b>NSBadRTFColorTableException</b>;<p>
<p>
NSString *<b>NSBadRTFDirectiveException</b>;<p>
<p>
NSString *<b>NSBadRTFFontTableException</b>;<p>
<p>
NSString *<b>NSBadRTFStyleSheetException</b>;<p>
<p>
NSString *<b>NSBrowserIllegalDelegateException</b>;<p>
<p>
NSString *<b>NSColorListIOException</b>;<p>
<p>
NSString *<b>NSColorListNotEditableException</b>;<p>
<p>
NSString *<b>NSDraggingException</b>;<p>
<p>
NSString *<b>NSFontUnavailableException</b>;<p>
<p>
NSString *<b>NSIllegalSelectorException</b>;<p>
<p>
NSString *<b>NSImageCacheException</b>;<p>
<p>
NSString *<b>NSNibLoadingException</b>;<p>
<p>
NSString *<b>NSPPDIncludeNotFoundException</b>;<p>
<p>
NSString *<b>NSPPDIncludeStackOverflowException</b>;<p>
<p>
NSString *<b>NSPPDIncludeStackUnderflowException</b>;<p>
<p>
NSString *<b>NSPPDParseException</b>;<p>
<p>
NSString *<b>NSPasteboardCommunicationException</b>;<p>
<p>
NSString *<b>NSPrintOperationExistsException</b>;		(Defined in
NSPrintOperation.h.)<p>
<p>
NSString *<b>NSPrintPackageException</b>;<p>
<p>
NSString *<b>NSPrintingCommunicationException</b>;<p>
<p>
NSString *<b>NSRTFPropertyStackOverflowException</b>;<p>
<p>
NSString *<b>NSTIFFException</b>;<p>
<p>
NSString *<b>NSTextLineTooLongException</b>;<p>
<p>
NSString *<b>NSTextNoSelectionException</b>;<p>
<p>
NSString *<b>NSTextReadException</b>;<p>
<p>
NSString *<b>NSTextWriteException</b>;<p>
<p>
NSString *<b>NSTypedStreamVersionException</b>;<p>
<p>
NSString *<b>NSWindowServerCommunicationException</b>;<p>
<p>
NSString *<b>NSWordTablesReadException</b>;<p>
<p>
NSString *<b>NSWordTablesWriteException</b>;<p>

<hr>
<b>Fonts</b><p>

<b></b>typedef unsigned int <b>NSFontTraitMask</b>;	Characterizes one or more
of a font's traits. It's used as an argument type for several of the methods in
the NSFontManager class. You build a mask by OR'ing together the following
enumeration constants.<p>
<p>
enum {	Values used by NSFontManager to identify font traits.<p>
<b>NSItalicFontMask</b>,<p>
<b>NSBoldFontMask</b>,<p>
<b>NSUnboldFontMask</b>,<p>
<b>NSNonStandardCharacterSetFontMask</b>,<p>
<b>NSNarrowFontMask</b>,<p>
<b>NSExpandedFontMask</b>,<p>
<b>NSCondensedFontMask</b>,<p>
<b>NSSmallCapsFontMask</b>,<p>
<b>NSPosterFontMask</b>,<p>
<b>NSCompressedFontMask</b>,<p>
<b>NSUnitalicFontMask</b><p>
<b></b>};<p>
<p>
typedef unsigned int <b>NSGlyph</b>;	A type for numbers identifying font
glyphs. It's used as the argument type for several of the methods in NSFont.<p>
<p>
enum {	Tags identifying views in the font panel.<p>
<b>NSFPPreviewButton</b> ,<p>
<b>NSFPRevertButton</b>,<p>
<b>NSFPSetButton</b>,<p>
<b>NSFPPreviewField</b>,<p>
<b>NSFPSizeField</b>,<p>
<b>NSFPSizeTitle</b>,<p>
<b>NSFPCurrentField</b><p>
<b></b>};<p>
<p>
const float *<b>NSFontIdentityMatrix</b>;	Identifies a font matrix that's used
for fonts displayed in an <p>
		NSView object that has an unflipped coordinate system.<p>
<p>
NSString *<b>NSAFMAscender</b>;	Global keys to access the values available in
the AFM <p>
NSString *<b>NSAFMCapHeight</b>;		dictionary. You can convert the appropriate<p>
NSString *<b>NSAFMCharacterSet</b>;		values (e.g., ascender, cap height) to
floating point<p>
NSString *<b>NSAFMDescender</b>;		values by using NSString's <b>floatValue</b>
method.<p>
NSString *<b>NSAFMEncodingScheme</b>;<p>
NSString *<b>NSAFMFamilyName</b>;<p>
NSString *<b>NSAFMFontName</b>;<p>
NSString *<b>NSAFMFormatVersion</b>;<p>
NSString *<b>NSAFMFullName</b>;<p>
NSString *<b>NSAFMItalicAngle</b>;<p>
NSString *<b>NSAFMMappingScheme</b>;<p>
NSString *<b>NSAFMNotice</b>;<p>
NSString *<b>NSAFMUnderlinePosition</b>;<p>
NSString *<b>NSAFMUnderlineThickness</b>;<p>
NSString *<b>NSAFMVersion</b>;<p>
NSString *<b>NSAFMWeight</b>;<p>
NSString *<b>NSAFMXHeight</b>;<p>

<hr>
<b>Graphics</b><p>

<b></b>typedef int <b>NSWindowDepth</b>	This type gives the window-depth limit.
Use the NSAvailableWindowDepths() function to get a list of available window
depths. Use the functions <b>NSBitsPerSampleFromDepth()</b>,
<b>NSBitsPerPixelFromDepth()</b>, <b>NSPlanarFromDepth</b>, and
<b>NSColorSpaceFromDepth()</b> to extract information from a window depth. The
NSWindowDepth type is also used as an argument type of methods in NSScreen and
NSWindow.<p>
<p>
typedef enum _NSTIFFCompression {	The constants defined in this type represent
the various<p>
<b>NSTIFFCompressionNone</b>  = 1,		TIFF (<i>tag image file format</i>) data
compression <p>
<b>NSTIFFCompressionCCITTFAX3</b>  = 3,		schemes. They are defined in
NSBitMapImageRep and <p>
<b>NSTIFFCompressionCCITTFAX4</b>  = 4,		used in several methods of that class
as well as in<p>
<b>NSTIFFCompressionLZW</b>  = 5,		the
<b>TIFFRepresentationUsingCompression:factor:</b><p>
<b>NSTIFFCompressionJPEG</b>  = 6,		method of NSImage.<p>
<b>NSTIFFCompressionNEXT</b>  = 32766,<p>
<b>NSTIFFCompressionPackBits</b>  = 32773,<p>
<b>NSTIFFCompressionOldJPEG</b>  = 32865<p>
} <b>NSTIFFCompression</b>;<p>
<p>
enum {	<b>NSImageRepMatchesDevice</b> indicates that the value <p>
<b>NSImageRepMatchesDevice</b>		varies according to the output device. It can
be<p>
};		passed in (or received back) as the value of NSImageRep's
<b>bitsPerSample</b>, <b>pixelsWide</b>, and <b>pixelsHigh</b>.<p>

<hr>
<b>Colorspace Names </b><p>


Predefined colorspace names. Used as arguments in <b>NSDrawBitMap()</b> and
<b>NSNumberOfColorComponents()</b>; value returned from
<b>NSColorSpaceFromDepth()</b>.<p>
<p>
NSString *<b>NSCalibratedWhiteColorSpace</b>; <p>
<p>
NSString *<b>NSCalibratedBlackColorSpace</b>; <p>
<p>
NSString *<b>NSCalibratedRGBColorSpace</b>;<p>
<p>
NSString *<b>NSDeviceWhiteColorSpace</b>;<p>
<p>
NSString *<b>NSDeviceBlackColorSpace</b>;<p>
<p>
NSString *<b>NSDeviceRGBColorSpace</b>;<p>
<p>
NSString *<b>NSDeviceCMYKColorSpace</b>;<p>
<p>
NSString *<b>NSNamedColorSpace</b>;<p>
<p>
NSString *<b>NSCustomColorSpace</b>;<p>

<hr>
<b>Gray Values </b><p>


Standard gray values for the 2-bit deep grayscale colorspace.<p>
<p>
const float <b>NSBlack</b>;<p>
<p>
const float <b>NSDarkGray</b>;<p>
<p>
const float <b>NSWhite</b>;<p>
<p>
const float <b>NSLightGray</b>;<p>

<hr>
<b>Device Dictionary Keys </b><p>


Keys to get designated values from device dictionaries.<p>
<p>
NSString *<b>NSDeviceResolution</b>;<p>
<p>
NSString *<b>NSDeviceColorSpaceName</b><p>

NSString *<b>NSDeviceBitsPerSample</b>;<p>
<p>
NSString *<b>NSDeviceIsScreen</b>;<p>
<p>
NSString *<b>NSDeviceIsPrinter</b>;<p>
<p>
NSString *<b>NSDeviceSize</b>;<p>

<hr>
<b>Matrix</b><p>

<b></b>typedef enum _NSMatrixMode {	The constants in this type represent the
modes of operation<p>
<b>NSRadioModeMatrix</b>,		of an NSMatrix.<p>
<b>NSHighlightModeMatrix</b>,<p>
<b>NSListModeMatrix</b>,<p>
<b>NSTrackModeMatrix</b> <p>
} <b>NSMatrixMode</b>;<p>

<hr>
<b>Notifications</b><p>

<b></b>Notifications are posted to all interested observers of a specific
condition to alert them that the condition has occurred. Global strings contain
the actual text of the notification. In the Application Kit, these are defined
per class. See the Foundation's NSNotification and NSNotificationCenter for
details.<p>
<p>
NSString *<b>NSApplicationDidBecomeActiveNotification</b>;	 NSApplication<p>
<p>
NSString *<b>NSApplicationDidFinishLaunchingNotification</b>;<p>
<p>
NSString *<b>NSApplicationDidHideNotification</b>;<p>
<p>
NSString *<b>NSApplicationDidResignActiveNotification</b>;<p>
<p>
NSString *<b>NSApplicationDidUnhideNotification</b>;<p>
<p>
NSString *<b>NSApplicationDidUpdateNotification</b>;<p>
<p>
NSString *<b>NSApplicationWillBecomeActiveNotification</b>;<p>
<p>
NSString *<b>NSApplicationWillFinishLaunchingNotification</b>;<p>
<p>
NSString *<b>NSApplicationWillHideNotification</b>;<p>
<p>
NSString *<b>NSApplicationWillResignActiveNotification</b>;<p>
<p>
NSString *<b>NSApplicationWillUnhideNotification</b>;<p>
<p>
NSString *<b>NSApplicationWillUpdateNotification</b>;<p>
<p>
<p>
<p>
NSString *<b>NSColorListChangedNotification</b>;			NSColorList<p>
<p>
NSString *<b>NSColorPanelColorChangedNotification</b>;		NSColorPanel<p>
<p>
<p>
<p>
NSString *<b>NSControlTextDidBeginEditingNotification</b>;	NSControl<p>
<p>
NSString *<b>NSControlTextDidEndEditingNotification</b>;<p>
<p>
NSString *<b>NSControlTextDidChangeNotification</b>;<p>
<p>
<p>
<p>
NSString *<b>NSImageRepRegistryChangedNotification</b>;	NSImageRep<p>
<p>
<p>
<p>
NSString *<b>NSSplitViewDidResizeSubviewsNotification</b>;	NSSplitView<p>
<p>
NSString *<b>NSSplitViewWillResizeSubviewsNotification</b>;<p>
<p>
<p>
<p>
NSString <b>*NSTextDidBeginEditingNotification;</b>			NSText<p>
<p>
NSString <b>*NSTextDidEndEditingNotification;</b><p>

NSString <b>*NSTextDidChangeNotification;</b><p>

<p>
<p>
NSString *<b>NSViewFrameChangedNotification</b>;			NSView<p>
<p>
NSString *<b>NSViewFocusChangedNotification</b>;<p>
<p>
<p>
<p>
NSString *<b>NSWindowDidBecomeKeyNotification</b>;		NSWindow<p>
<p>
NSString *<b>NSWindowDidBecomeMainNotification</b>;<p>
<p>
NSString *<b>NSWindowDidChangeScreenNotification</b>;<p>
<p>
NSString *<b>NSWindowDidDeminiaturizeNotification</b>;<p>
<p>
NSString *<b>NSWindowDidExposeNotification</b>;<p>
<p>
NSString *<b>NSWindowDidMiniaturizeNotification</b>;<p>
<p>
NSString *<b>NSWindowDidMoveNotification</b>;<p>
<p>
NSString *<b>NSWindowDidResignKeyNotification</b>;<p>
<p>
NSString *<b>NSWindowDidResignMainNotification</b>;<p>
<p>
NSString *<b>NSWindowDidResizeNotification</b>;<p>
<p>
NSString *<b>NSWindowDidUpdateNotification</b>;<p>
<p>
NSString *<b>NSWindowWillCloseNotification</b>;<p>
<p>
NSString *<b>NSWindowWillMiniaturizeNotification</b>;<p>
<p>
NSString *<b>NSWindowWillMoveNotification</b>;<p>
<p>
<p>
<p>
NSString *<b>NSWorkspaceDidLaunchApplicationNotification</b>;	NSWorkspace<p>
<p>
NSString *<b>NSWorkspaceDidMountNotification</b>;<p>
<p>
NSString *<b>NSWorkspaceDidPerformFileOperationNotification</b>;<p>
<p>
NSString *<b>NSWorkspaceDidTerminateApplicationNotification</b>;<p>
<p>
NSString *<b>NSWorkspaceDidUnmountNotification</b>;<p>
<p>
NSString *<b>NSWorkspaceWillLaunchApplicationNotification</b>;<p>
<p>
NSString *<b>NSWorkspaceWillPowerOffNotification</b>;<p>
<p>
NSString *<b>NSWorkspaceWillUnmountNotification</b>;<p>

<hr>
<b>Panel</b><p>

<b></b>enum {	Values returned by the standard panel buttons, <p>
<b>NSOKButton</b> = 1,		OK and Cancel.<p>
<b>NSCancelButton</b> = 0<p>
};<p>
<p>
enum {	Values returned by the <b>NSRunAlertPanel()</b> function and<p>
<b>NSAlertDefaultReturn</b> = 1,		by <b>runModalSession:</b> when the modal
session is run <p>
<b>NSAlertAlternateReturn</b> = 0,		with a Panel provided by
<b>NSGetAlertPanel()</b>.<p>
<b>NSAlertOtherReturn</b> = -1,<p>
<b>NSAlertErrorReturn</b>  = -2<p>
};	 <p>

<hr>
<b>Page Layout</b><p>

<b></b>enum {	Tags that identify buttons, fields, and other views of the<p>
<b>NSPLImageButton</b>,		Page Layout panel.<p>
<b>NSPLTitleField</b>,<p>
<b>NSPLPaperNameButton</b>,<p>
<b>NSPLUnitsButton</b>,<p>
<b>NSPLWidthForm</b>,<p>
<b>NSPLHeightForm</b>,<p>
<b>NSPLOrientationMatrix</b>,<p>
<b>NSPLCancelButton</b>,<p>
<b>NSPLOKButton</b> <p>
};<p>

<hr>
<b>Pasteboard</b><p>

<b>Pasteboard Type Globals </b><p>

Identifies the standard pasteboard types. These are used in a variety of
NSPasteboard methods and functions.<p>
<p>
NSString *<b>NSStringPboardType</b>;<p>
<p>
NSString *<b>NSColorPboardType</b>;<p>
<p>
NSString *<b>NSFileContentsPboardType</b>;<p>
<p>
NSString *<b>NSFilenamesPboardType</b>;<p>
<p>
NSString *<b>NSFontPboardType</b>;<p>
<p>
NSString *<b>NSRulerPboardType</b>;<p>
<p>
NSString *<b>NSPostScriptPboardType</b>;<p>
<p>
NSString *<b>NSTabularTextPboardType</b>;<p>
<p>
NSString *<b>NSRTFPboardType</b>;<p>
<p>
NSString *<b>NSTIFFPboardType</b>;<p>
<p>
NSString *<b>NSDataLinkPboardType</b>;		(Defined in NSDataLink.h.)<p>
<p>
NSString *<b>NSGeneralPboardType</b>;		(Defined in NSSelection.h.)<p>

<b>Pasteboard Name Globals </b><p>


Identifies the standard pasteboard names. Used in class method
<b>pasteboardWithName:</b> to get a pasteboard by name.<p>
<p>
NSString *<b>NSDragPboard</b>;<p>
<p>
NSString *<b>NSFindPboard</b>;<p>
<p>
NSString *<b>NSFontPboard</b>;<p>
<p>
NSString *<b>NSGeneralPboard</b>;<p>
<p>
NSString *<b>NSRulerPboard</b>;<p>

<hr>
<b>Printing</b><p>

<b></b>typedef enum _NSPrinterTableStatus {	These constants describe the state
of a printer-information<p>
<b>NSPrinterTableOK</b>,		 table stored by an NSPrinter object. It is the
argument<p>
<b>NSPrinterTableNotFound</b>,		type of the return value of
<b>statusForTable:</b>.<p>
<b>NSPrinterTableError</b><p>
<b></b>} <b>NSPrinterTableStatus</b>;<p>
<p>
typedef enum _NSPrintingOrientation {	These constants represent the way a page
is oriented for <p>
<b>NSPortraitOrientation</b>,		printing.<p>
<b>NSLandscapeOrientation</b><p>
<b></b>} <b>NSPrintingOrientation</b>;<p>
<p>
typedef enum _NSPrintingPageOrder {	These constants describe the order in which
pages are <p>
<b>NSDescendingPageOrder</b>,		spooled for printing. <b>NSSpecialPageOrder</b>
tells the <p>
<b>NSSpecialPageOrder</b>,		spooler not to rearrange pages. Set through <p>
<b>NSAscendingPageOrder</b>,		NSPrintingOperation's <b>setPageOrder:</b> method
and <p>
<b>NSUnknownPageOrder</b>		returned by its <b>pageOrder</b> method.<p>
} <b>NSPrintingPageOrder</b>;<p>
<p>
typedef enum _NSPrintingPaginationMode {	These constants represent the
different ways an image is <p>
<b>NSAutoPagination</b>,		divided into pages during pagination. Pagination can
<p>
<b>NSFitPagination</b>,		occur automatically, the image can be forced onto a <p>
<b>NSClipPagination</b>		page, or it can be clipped to a page.<p>
} <b>NSPrintingPaginationMode</b>;<p>
<p>
enum {	Tags that identify text fields, controls, and other views in <p>
<b>NSPPSaveButton</b>,		the Print Panel.<p>
<b>NSPPPreviewButton</b>,<p>
<b>NSFaxButton</b>,<p>
<b>NSPPTitleField</b>,<p>
<b>NSPPImageButton</b>,<p>
<b>NSPPNameTitle</b>,<p>
<b>NSPPNameField</b>,<p>
<b>NSPPNoteTitle</b>,<p>
<b>NSPPNoteField</b>,<p>
<b>NSPPStatusTitle</b>,<p>
<b>NSPPStatusField</b>,<p>
<b>NSPPCopiesField</b>,<p>
<b>NSPPPageChoiceMatrix</b>,<p>
<b>NSPPPageRangeFrom</b>,<p>
<b>NSPPPageRangeTo</b>,<p>
<b>NSPPScaleField</b>,<p>
<b>NSPPOptionsButton</b>,<p>
<b>NSPPPaperFeedButton</b>,<p>
<b>NSPPLayoutButton</b><p>
<b></b>};<p>

<b>Printing Information Dictionary Keys </b><p>


The keys in the mutable dictionary associated with NSPrintingInfo. See
NSPrintingInfo.h for types and descriptions of values.<p>
<p>
NSString *<b>NSPrintAllPages</b>;<p>
<p>
NSString *<b>NSPrintBottomMargin</b>;<p>
<p>
NSString *<b>NSPrintCopies</b>;<p>
<p>
NSString *<b>NSPrintFaxCoverSheetName</b>;<p>
<p>
NSString *<b>NSPrintFaxHighResolution</b>;<p>
<p>
NSString *<b>NSPrintFaxModem</b>;<p>
<p>
NSString *<b>NSPrintFaxReceiverNames</b>;<p>
<p>
NSString *<b>NSPrintFaxReceiverNumbers</b>;<p>
<p>
NSString *<b>NSPrintFaxReturnReceipt</b>;<p>
<p>
NSString *<b>NSPrintFaxSendTime</b>;<p>
<p>
NSString *<b>NSPrintFaxTrimPageEnds</b>;<p>
<p>
NSString *<b>NSPrintFaxUseCoverSheet</b>;<p>
<p>
NSString *<b>NSPrintFirstPage</b>;<p>
<p>
NSString *<b>NSPrintHorizonalPagination</b>;<p>
<p>
NSString *<b>NSPrintHorizontallyCentered</b>;<p>
<p>
NSString *<b>NSPrintJobDisposition</b>;<p>
<p>
NSString *<b>NSPrintJobFeatures</b>;<p>
<p>
NSString *<b>NSPrintLastPage</b>;<p>
<p>
NSString *<b>NSPrintLeftMargin</b>;<p>
<p>
NSString  *<b>NSPrintManualFeed</b>;<p>
<p>
NSString *<b>NSPrintOrientation</b>;<p>
<p>
NSString *<b>NSPrintPackageException</b>;<p>
<p>
NSString *<b>NSPrintPagesPerSheet</b>;<p>
<p>
NSString *<b>NSPrintPaperFeed</b>;<p>
<p>
NSString *<b>NSPrintPaperName</b>;<p>
<p>
NSString *<b>NSPrintPaperSize</b>;<p>
<p>
NSString *<b>NSPrintPrinter</b>;<p>
<p>
NSString *<b>NSPrintReversePageOrder</b>;<p>
<p>
NSString *<b>NSPrintRightMargin</b>;<p>
<p>
NSString *<b>NSPrintSavePath</b>;<p>
<p>
NSString *<b>NSPrintScalingFactor</b>;<p>
<p>
NSString *<b>NSPrintTopMargin</b>;<p>
<p>
NSString *<b>NSPrintVerticalPagination</b>;<p>
<p>
NSString *<b>NSPrintVerticallyCentered</b>;<p>

<b>Print Job Disposition Values </b><p>


These global constants define the disposition of a print job. See NSPrintInfo's
<b>setJobDisposition:</b> and <b>jobDisposition</b>.<p>
<p>
NSString  *<b>NSPrintCancelJob</b>;<p>
<p>
NSString  *<b>NSPrintFaxJob</b>;<p>
<p>
NSString  *<b>NSPrintPreviewJob</b>;<p>
<p>
NSString  *<b>NSPrintSaveJob</b>;<p>
<p>
NSString  *<b>NSPrintSpoolJob</b>;<p>

<hr>
<b>Save Panel</b><p>

<b></b>enum {	Tags that identify buttons, fields, and other views in the <p>
<b>NSFileHandlingPanelImageButton</b>,		Save Panel.<p>
<b>NSFileHandlingPanelTitleField</b>,<p>
<b>NSFileHandlingPanelBrowser</b>,<p>
<b>NSFileHandlingPanelCancelButton</b>,<p>
<b>NSFileHandlingPanelOKButton</b>,<p>
<b>NSFileHandlingPanelForm</b>, <p>
<b>NSFileHandlingPanelHomeButton</b>, <p>
<b>NSFileHandlingPanelDiskButton</b>, <p>
<b>NSFileHandlingPanelDiskEjectButton</b> <p>
};<p>

<hr>
<b>Scroller</b><p>

<b></b>typedef enum _NSScrollArrowPosition {	NSScroller uses these constants in
its <b>setArrowPosition:</b><p>
<b>NSScrollerArrowsMaxEnd</b>,		method to set the position of the arrows within
the<p>
<b>NSScrollerArrowsMinEnd</b>,		scroller.<p>
<b>NSScrollerArrowsNone</b> <p>
} <b>NSScrollArrowPosition</b>;<p>
<p>
typedef enum _NSScrollerPart {	NSScroller uses these constants in its
<b>hitPart</b> method to<p>
<b>NSScrollerNoPart</b>,		identify the part of the scroller specified in a
mouse<p>
<b>NSScrollerDecrementPage</b>,		event.<p>
<b>NSScrollerKnob</b>,<p>
<b>NSScrollerIncrementPage</b>,<p>
<b>NSScrollerDecrementLine</b>,<p>
<b>NSScrollerIncrementLine</b>,<p>
<b>NSScrollerKnobSlot</b> <p>
} <b>NSScrollerPart</b>;<p>
<p>
typedef enum _NSScrollerUsablePart {	These constants define the usable parts of
an NSScroller<p>
<b>NSNoScrollerParts</b>,		object.<p>
<b>NSOnlyScrollerArrows</b>,<p>
<b>NSAllScrollerParts</b>  <p>
} <b>NSUsableScrollerParts</b>;<p>
<p>
typedef enum _NSScrollerArrow {	These constants indicate the two types of
scroller arrow.<p>
<b>NSScrollerIncrementArrow</b>,		NSScroller's <b>drawArrow:highlight:</b>
method takes an<p>
<b>NSScrollerDecrementArrow</b>		 NSScrollerArrow as the first argument.<p>
} <b>NSScrollerArrow</b>;<p>
<p>
const float <b>NSScrollerWidth</b>;	Identifies the default width of a vertical
NSScroller object and the default height of a horizontal NSScroller object. <p>

<hr>
<b>Text</b><p>

<b></b>typedef struct _NSBreakArray {	Holds line-break information for an
NSText object. It's <p>
NSTextChunk <b>chunk</b>;		mainly an array of line descriptors.<p>
NSLineDesc  <b>breaks</b>[1];<p>
} <b>NSBreakArray</b>;<p>
<p>
typedef struct _NSCharArray {	Holds the character array for the current line in
the NSText<p>
NSTextChunk <b>chunk</b>;		object.<p>
unsigned char <b>text</b>[1];<p>
} <b>NSCharArray</b>;<p>
<p>
typedef unsigned short (*<b>NSCharFilterFunc</b>) (	The character filter
function analyzes each character the <p>
unsigned short <i>charCode</i>, 		user enters in the NSText object.<p>
int <i>flags</i>, <p>
NSStringEncoding <i>theEncoding</i>);<p>
<p>
typedef struct _NSFSM {	A word definition finite-state machine structure used
by an<p>
const struct _NSFSM  *<b>next</b>;		NSText object.<p>
short   <b>delta</b>;<p>
short   <b>token</b>;<p>
} <b>NSFSM</b>;<p>
<p>
typedef struct _NSHeightChange {	Associates line descriptors and line-height
information in<p>
NSLineDesc  <b>lineDesc</b>;		an NSText object.<p>
NSHeightInfo <b>heightInfo</b>;<p>
} <b>NSHeightChange</b>;<p>
<p>
typedef struct _NSHeightInfo {	Stores height information for each line of text
in an NSText<p>
float <b>newHeight</b>;		object.<p>
float <b>oldHeight</b>;<p>
NSLineDesc  <b>lineDesc</b>;<p>
} <b>NSHeightInfo</b>;<p>
<p>
typedef struct _NSLay {	Represents a single sequence of text in a line and
records<p>
float <b>x</b>;		everything needed to select or draw that piece.<p>
float <b>y</b>;<p>
short   <b>offset</b>;<p>
short   <b>chars</b>;<p>
id  <b>font</b>;<p>
void   *<b>paraStyle</b>;<p>
NSRun *<b>run</b>;<p>
NSLayFlags <b>lFlags</b>;<p>
} <b>NSLay</b>;<p>
<p>
typedef struct _NSLayArray {	Holds the layout for the current line. Since the
structure's <p>
NSTextChunk <b>chunk</b>;		first field is an <b>NSTextChunk</b> structure,
<b>NSLayArray</b>s <p>
NSLay   <b>lays</b>[1];		can be manipulated by the functions that manage <p>
} <b>NSLayArray</b>;		variable-sized arrays of records.<p>
<p>
typedef struct {	Records whether a text lay in an NSText object needs<p>
unsigned int <b>mustMove</b>:1;		special treatment (e.g., because of
non-printing <p>
unsigned int <b>isMoveChar</b>:1;		characters).<p>
unsigned int RESERVED:14;<p>
} <b>NSLayFlags</b>;<p>
<p>
typedef struct _NSLayInfo {	NSText's scanning and drawing functions use this <p>
NSRect <b>rect</b>;		structure to communicate information about lines of<p>
float <b>descent</b>;		text.<p>
float <b>width</b>;<p>
float <b>left</b>;<p>
float <b>right</b>;<p>
float <b>rightIndent</b>;<p>
NSLayArray *<b>lays</b>;<p>
NSWidthArray *<b>widths</b>;<p>
NSCharArray *<b>chars</b>;<p>
NSTextCache <b>cache</b>;<p>
NSRect *<b>textClipRect</b>;<p>
struct _lFlags {<p>
    unsigned int <b>horizCanGrow</b>:1;<p>
    unsigned int <b>vertCanGrow</b>:1;<p>
    unsigned int <b>erase</b>:1;<p>
    unsigned int <b>ping</b>:1;<p>
    unsigned int <b>endsParagraph</b>:1;<p>
    unsigned int <b>resetCache</b>:1;<p>
    unsigned int RESERVED:10;<p>
} <b>lFlags</b>;<p>
} <b>NSLayInfo</b>;<p>
<p>
typedef short <b>NSLineDesc</b>;	Used to identify lines of text in the NSText
object.<p>
<p>
typedef enum _NSParagraphProperty {	The constants of this type identify
specific <p>
<b>NSLeftAlignedParagraph</b>,		paragraph properties for selected text. <p>
<b>NSRightAlignedParagraph</b>,		NSText's s<b>etSelProp:</b> method takes this
<p>
<b>NSCenterAlignedParagraph</b>,		argument type.<p>
<b>NSJustificationAlignedParagraph</b>,<p>
<b>NSFirstIndentParagraph</b>,<p>
<b>NSIndentParagraph</b>,<p>
<b>NSAddTabParagraph</b>,<p>
<b>NSRemoveTabParagraph</b>,<p>
<b>NSLeftMarginParagraph</b>,<p>
<b>NSRightMarginParagraph</b>  <p>
} <b>NSParagraphProperty</b>;<p>
<p>
typedef struct _NSRun {	In an NSText object, this structure represents a single
<p>
id  <b>font</b>;		sequence of text with a given format.<p>
int <b>chars</b>;<p>
void   *<b>paraStyle</b>;<p>
int  <b>textRGBColor</b>;<p>
unsigned char   <b>superscript</b>;<p>
unsigned char   <b>subscript</b>;<p>
id   <b>info</b>;<p>
NSRunFlags <b>rFlags</b>;<p>
} <b>NSRun</b>;<p>
<p>
typedef struct _NSRunArray {	This structure holds the array of text runs in an
NSText <p>
NSTextChunk <b>chunk</b>;		object. Since the first field is an NSTextChunk
structure<p>
NSRun   <b>runs</b>[1];		you can manipulate the items in the array with the <p>
} <b>NSRunArray</b>;		functions that manage variable-sized arrays of records.<p>
<p>
typedef struct {	The fields of this structure record whether a run in an <p>
unsigned int <b>underline</b>:1;		NSText object contains graphics, is
underlined, or <p>
unsigned int <b>dummy</b>:1;		if an alternate character forced the use of a
symbol.<p>
unsigned int <b>subclassWantsRTF</b>:1;<p>
unsigned int <b>graphic</b>:1;<p>
unsigned int <b>forcedSymbol</b>:1;<p>
unsigned int RESERVED:11;<p>
} <b>NSRunFlags</b>;<p>
<p>
typedef struct _NSSelPt {	Represents one end of a selection in an NSText
object.<p>
int <b>cp</b>;		Character position.<p>
int <b>line</b>;		Offset of LineDesc in break table.<p>
float <b>x</b>;		x coordinate.<p>
float <b>y</b>;		y coordinate.<p>
int <b>c1st</b>;		Character position of first character in the line.<p>
float <b>ht</b>;		Line height.<p>
} <b>NSSelPt</b>;<p>
<p>
typedef struct _NSTabStop {	This structure describes an NSText object's tab
stops.<p>
short   <b>kind</b>;<p>
float <b>x</b>;<p>
} <b>NSTabStop</b>;<p>
<p>
typedef struct _NSTextBlock {	A structure holds text characters in blocks no
bigger than<p>
struct _NSTextBlock *<b>next</b>;		<b>NSTextBlockSize</b> (see below). A linked
list of these<p>
struct _NSTextBlock *<b>prior</b>;		text blocks comprises the text for an
NSText<p>
struct _tbFlags {		object.<p>
     unsigned int <b>malloced</b>:1;<p>
     unsigned int <b>PAD</b>:15;<p>
} <b>tbFlags</b>;<p>
short   <b>chars</b>;<p>
unsigned char *<b>text</b>;<p>
} <b>NSTextBlock</b>;<p>
<p>
typedef struct _NSTextCache {	This structure describes the current text block
and run, and<p>
int <b>curPos</b>;		the cursor position in the text.<p>
NSRun *<b>curRun</b>;<p>
int <b>runFirstPos</b>;<p>
NSTextBlock *<b>curBlock</b>;<p>
int <b>blockFirstPos</b>;<p>
} <b>NSTextCache</b>;<p>
<p>
typedef struct _NSTextChunk {	NSText uses this structure to implement
variable-sized <p>
short   <b>growby</b>;		arrays of records.<p>
int <b>allocated</b>;<p>
int <b>used</b>;<p>
} <b>NSTextChunk</b>;<p>
<p>
typedef char  *(*<b>NSTextFilterFunc</b>) (	A text filter function implements
autoindenting and other <p>
id self, 		features in an NSText object.<p>
unsigned char * insertText, <p>
int *insertLength, <p>
int position);<p>
<p>
typedef int (*<b>NSTextFunc</b>) (	This is the type for an NSText object's
scanning and <p>
id self, 		drawing function, as set through the <b>setScanFunc:</b><p>
<b></b>NSLayInfo *layInfo);		and <b>setDrawFunc:</b> methods.<p>
<p>
typedef enum _NSTextAlignment {	The constants of this type determine text
alignment. Used<p>
<b>NSLeftTextAlignment</b>,		by methods of NSCell, NSControl, NSForm, <p>
<b>NSRightTextAlignment</b>,		NSFormCell, and NSText.
<b>NSNaturalTextAlignment</b><p>
<b>NSCenterTextAlignment</b>,		indicates the default alignment for the text.<p>
<b>NSJustifiedTextAlignment</b>,<p>
<b>NSNaturalTextAlignment</b><p>
<b></b>} <b>NSTextAlignment</b>;<p>
<p>
typedef struct _NSTextStyle {	NSText uses this structure to describe text
layout and tab <p>
float <b>indent1st</b>;		stops.<p>
float <b>indent2nd</b>;<p>
float <b>lineHt</b>;<p>
float <b>descentLine</b>;<p>
NSTextAlignment   <b>alignment</b>;<p>
short   <b>numTabs</b>;<p>
NSTabStop  *<b>tabs</b>;<p>
} <b>NSTextStyle</b>;<p>
<p>
typedef struct _NSWidthArray {	Holds the character widths for the current
line.<p>
NSTextChunk <b>chunk</b>;		Since the first field is an NSTextChunk structure<p>
float <b>widths</b>[1];		you can manipulate the items in the array with the<p>
} <b>NSWidthArray</b>;		functions that manage variable-sized arrays of
records.<p>
<p>
enum {	This constant is used by the NSText<p>
<b>NSLeftTab</b> 		object's tab functions.<p>
};<p>
<p>
enum {	These character-code constants are used by the NSText<p>
<b>NSBackspaceKey</b>   = 8,		object's character filter function.<p>
<b>NSCarriageReturnKey</b>   = 13,<p>
<b>NSDeleteKey</b>= 0x7f,<p>
<b>NSBacktabKey</b>   = 25<p>
};<p>
<p>
enum {<p>
<b>NSIllegalTextMovement</b>  = 0,	Movement codes describing types of movement
between text  <p>
<b>NSReturnTextMovement</b>  = 0x10,		fields. Passed in toNSText delegates as
the last argument <p>
<b>NSTabTextMovement</b>   = 0x11,		of <b>textDidEnd:endChar:</b>.<p>
<b>NSBacktabTextMovement</b>  = 0x12,<p>
<b>NSLeftTextMovement</b>   = 0x13,<p>
<b>NSRightTextMovement</b>   = 0x14,<p>
<b>NSUpTextMovement</b>   = 0x15,<p>
<b>NSDownTextMovement</b>   = 0x16<p>
};	 	<p>
<p>
enum {	The size, in bytes, of a text block.<p>
<b>NSTextBlockSize</b>   = 512<p>
};<p>

<hr>
<b>Break Tables </b><p>

These tables (with their associated sizes) are finite-state machines that
determine word wrapping in an NSText object.<p>
<p>
const NSFSM *<b>NSCBreakTable</b>;<p>
<p>
int <b>NSCBreakTableSize</b>;<p>
<p>
const NSFSM *<b>NSEnglishBreakTable</b>;<p>
<p>
int <b>NSEnglishBreakTableSize</b>;<p>
<p>
const NSFSM *<b>NSEnglishNoBreakTable</b>;<p>
<p>
int <b>NSEnglishNoBreakTableSize</b>;<p>

<hr>
<b>Character Category Tables </b><p>


These tables define the character classes used in an NSText object's break and
click tables.<p>
<p>
const unsigned char *<b>NSCCharCatTable</b>;<p>
<p>
const unsigned char *<b>NSEnglishCharCatTable</b>;<p>

<hr>
<b>Click Tables </b><p>


NSText objects use these tables as finite-state machines that determine which
characters are selected when the user double-clicks.<p>
<p>
const NSFSM *<b>NSCClickTable</b>;<p>
<p>
int <b>NSCClickTableSize</b>;<p>
<p>
const NSFSM *<b>NSEnglishClickTable</b>;<p>
<p>
int <b>NSEnglishClickTableSize</b>;<p>

<hr>
<b>Smart Cut and Paste Tables </b><p>

These tables are suitable as arguments for the NSText methods
<b>setPreSelSmartable:</b> and <b>setPostSelSmartTable:</b>. When users paste
text into an NSText object, if the character to the left (right) side of the
new word is not in the left (right) table, an extra space is added to that
side.<p>
<p>
const unsigned char *<b>NSCSmartLeftChars</b>;<p>
<p>
const unsigned char *<b>NSCSmartRightChars</b>;<p>
<p>
const unsigned char *<b>NSEnglishSmartLeftChars</b>;<p>
<p>
const unsigned char *<b>NSEnglishSmartRightChars</b>;<p>

<hr>
<b>NSCStringText Internal State Structure</b><p>

This is the structure returned by the <b>cStringTextInternalState</b> method of
NSCStringText, for use only by applications that need to access the internal
state of an NSCStringText object.<p>
<p>
typedef struct _NSCStringTextInternalState  {<p>
const NSFSM *<b>breakTable</b>;	Pointer to state table that specifies word and
line breaks<p>
const NSFSM *<b>clickTable</b>;	Pointer to state table that defines word
boundaries for double-click selection<p>
const unsigned char *<b>preSelSmartTable</b>;	Pointer to table that specifies
which characters on the left end of a selection are treated as equivalent to a
space<p>
const unsigned char *<b>postSelSmartTable</b>;	Pointer to table that specifies
which characters on the right end of a selection are treated as equivalent to a
space<p>
const unsigned char *<b>charCategoryTable</b>;	Pointer to table that maps ASCII
characters to character classes. <p>
char <b>delegateMethods</b>;	Record of notification methods the delegate
implements<p>
NSCharFilterFunc <b>charFilterFunc</b>;	Function to check each character as
it's typed into the text<p>
NSTextFilterFunc <b>textFilterFunc</b>;	Function to check text that's being
added to the NSCStringText object<p>
NSString *<b>_string</b>;	Reserved for internal use<p>
NSTextFunc <b>scanFunc</b>;	Function that calculates the line of text<p>
NSTextFunc <b>drawFunc</b>;	Function that draws the line of text<p>
id <b>delegate</b>;	Object that's notified when the NSCStringText object is
modified<p>
int <b>tag</b>;	Integer the delegate uses to identify the NSCStringText
object<p>
void<b> *cursorTE</b>;	Timed entry number for the vertical bar that marks the
insertion point<p>
NSTextBlock *<b>firstTextBlock</b>;	Pointer to first record in a linked list of
text blocks<p>
NSTextBlock *<b>lastTextBlock</b>;	Pointer to last record in a linked list of
text blocks<p>
NSRunArray  *<b>theRuns</b>;	Pointer to array of format runs. By default,
<b>theRuns</b> points to a single run of the default font<p>
NSRun  <b>typingRun</b>;	Format run to use for the next characters entered<p>
NSBreakArray *<b>theBreaks</b>;	Pointer to the array of line breaks<p>
int <b>growLine</b>;	Line containing the end of the growing selection<p>
int <b>textLength</b>;	Number of characters in the NSCStringText object<p>
float <b>maxY</b>;	Bottom of the last line of text, relative to the origin of
<b>bodyRect</b><p>
<b></b>float <b>maxX</b>;	Widest line of text. Only accurate after
<b>calcLine</b> method is invoked<p>
NSRect <b>bodyRect</b>;	Rectangle in which the NSCStringText object draws<p>
float <b>borderWidth</b>;	Reserved for internal use<p>
char <b>clickCount</b>;	Number of clicks that created the selection<p>
NSSelPt <b>sp0</b>;	Starting position of the selection<p>
NSSelPt <b>spN</b>;	Ending position of the selection<p>
NSSelPt <b>anchorL</b>;	Left anchor position<p>
NSSelPt <b>anchorR</b>;	Right anchor position<p>
NSSize <b>maxSize</b>;	Maximum size of the frame rectangle<p>
NSSize <b>minSize</b>;	Minimum size of the frame rectangle<p>
struct <b>_tFlags</b> {<p>
#ifdef __BIG_ENDIAN__<p>
        unsigned int <b>_editMode</b>:2;	Reserved for internal use<p>
        unsigned int <b>_selectMode</b>:2;	Reserved for internal use<p>
        unsigned int <b>_caretState</b>:2;	Reserved for internal use<p>
        unsigned int <b>changeState</b>:1;	True if any changes have been made
to the text since the NSCStringText object became first responder<p>
        unsigned int <b>charWrap</b>:1;	True if the NSCStringText object wraps
words whose length exceeds the line length on a character basis. False if such
words are truncated at end of line<p>
        unsigned int <b>haveDown</b>:1;	True if the left mouse button (or any
button if button functions are not differentiated) is down<p>
        unsigned int <b>anchorIs0</b>:1;	True if the anchor's position is at
<b>sp0</b><p>
<b></b>        unsigned int <b>horizResizable</b>:1;	True if the NSCStringText
object's width can grow or shrink<p>
        unsigned int <b>vertResizable</b>:1;	True if the NSCStringText object's
height can grow or shrink<p>
        unsigned int <b>overstrikeDiacriticals</b>:1;	Reserved for internal
use<p>
        unsigned int <b>monoFont</b>:1;	True if the NSCStringText object uses
one font for all its text<p>
        unsigned int <b>disableFontPanel</b>:1;	True if the NSCStringText
object doesn't update the font panel automatically<p>
        unsigned int <b>inClipView</b>:1;	True if the NSCStringText object is a
subview of an NSClipView<p>
#else<p>
        unsigned int <b>inClipView</b>:1;<p>
        unsigned int <b>disableFontPanel</b>:1;<p>
        unsigned int <b>monoFont</b>:1;<p>
        unsigned int <b>overstrikeDiacriticals</b>:1;<p>
        unsigned int <b>vertResizable</b>:1;<p>
        unsigned int <b>horizResizable</b>:1;<p>
        unsigned int <b>anchorIs0</b>:1;<p>
        unsigned int <b>haveDown</b>:1;<p>
        unsigned int <b>charWrap</b>:1;<p>
        unsigned int <b>changeState</b>:1;<p>
        unsigned int <b>_caretState</b>:2;<p>
        unsigned int <b>_selectMode</b>:2;<p>
        unsigned int <b>_editMode</b>:2;<p>
#endif<p>
    } <b>tFlags</b>;<p>
    void *<b>_info</b>;	Reserved for internal use<p>
    void *<b>_textStr</b>;	Reserved for internal use<p>
}  <b>NSCStringTextInternalState</b>;<p>

<hr>
<b>View</b><p>

<b></b>typedef int <b>NSTrackingRectTag</b>;	A unique identifier of a tracking
rectangle assigned by NSView. (See <b>addTrackingRectangle:owner:
assumeInside:</b>.)<p>
<p>
typedef enum _NSBorderType {	Constants representing the four types of borders
that can<p>
<b>NSNoBorder</b>,		appear around NSView objects.<p>
<b>NSLineBorder</b>,<p>
<b>NSBezelBorder</b>,<p>
<b>NSGrooveBorder</b> <p>
} <b>NSBorderType</b>;<p>
<p>
enum {	NSView uses these autoresize constants to describe<p>
<b>NSViewNotSizable</b>,		the parts of a view (or its margins) that are
resized<p>
<b>NSViewMinXMargin</b>,		when the view's superview is resized.<p>
<b>NSViewWidthSizable</b>,<p>
<b>NSViewMaxXMargin</b>,<p>
<b>NSViewMinYMargin</b>,<p>
<b>NSViewHeightSizable</b>,<p>
<b>NSViewMaxYMargin</b> <p>
};<p>

<hr>
<b>Window </b><p>

<b></b>enum {	These constants list the window-device tiers that the<p>
<b>NSNormalWindowLevel</b>   = 0,		Application Kit uses. Windows are ordered
(or<p>
<b>NSFloatingWindowLevel</b>  = 3,		layered)
within tiers: The uppermost window in one<p>
<b>NSDockWindowLevel</b>   = 5,		tier can still be obscured by the lowest
window in<p>
<b>NSSubmenuWindowLevel</b>  = 10,		the next higher tier.<p>
<b>NSMainMenuWindowLevel</b>  = 20<p>
};<p>
<p>
enum {	Bitmap masks to determine certain window styles.<p>
<b>NSBorderlessWindowMask</b>,<p>
<b>NSTitledWindowMask</b>,<p>
<b>NSClosableWindowMask</b>,<p>
<b>NSMiniaturizableWindowMask</b>,<p>
<b>NSResizableWindowMask</b>  <p>
};<p>

<hr>
<b>Size Globals </b><p>

These global constants give the dimensions of an icon and contained.<p>
<p>
NSSize <b>NSIconSize</b>;<p>
<p>
NSSize <b>NSTokenSize</b>:<p>


<hr>
<b>Workspace</b><p>

<b>Workspace File Type Globals </b><p>

Identifies the type of file queried by the method
<b>getInfoForFile:application:type:</b> (passed back by reference in last
argument).<p>
<p>
NSString *<b>NSPlainFileType</b>;<p>
<p>
NSString *<b>NSDirectoryFileType</b>;<p>
<p>
NSString *<b>NSApplicationFileType</b>;<p>
<p>
NSString *<b>NSFilesystemFileType</b>;<p>
<p>
NSString *<b>NSShellCommandFileType</b>;<p>

<b>Workspace File Operation Globals </b><p>

Used as file-operation arguments in the
<b>performFileOperation:source:destination:files:options:</b> method (first
argument).<p>
<p>
NSString *<b>NSWorkspaceCompressOperation</b>;<p>
<p>
NSString *<b>NSWorkspaceCopyOperation</b>;<p>
<p>
NSString *<b>NSWorkspaceDecompressOperation</b>;<p>
<p>
NSString *<b>NSWorkspaceDecryptOperation</b>;<p>
<p>
NSString *<b>NSWorkspaceDestroyOperation</b>;<p>
<p>
NSString *<b>NSWorkspaceDuplicateOperation</b>;<p>
<p>
NSString *<b>NSWorkspaceEncryptOperation</b>;<p>
<p>
NSString *<b>NSWorkspaceLinkOperation</b>;<p>
<p>
NSString *<b>NSWorkspaceMoveOperation</b>;<p>
<p>
NSString *<b>NSWorkspaceRecycleOperation</b>;<p>
</body></html>
