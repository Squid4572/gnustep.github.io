<html><head><TITLE>CFunctions.html</TITLE><!-- This document was created from RTF source by rtftohtml version
2.7.4 --></head><body><A HREF="../../OpenStepSpec.html">Return to Contents</A><HR>
Copyright (c) 1994 by NeXT Computer, Inc.  All Rights
Reserved.<p>
<p>
<b></b><p>
<b>Application Kit Functions</b><p>
<b></b><p>
<b></b><p>
<b>Rectangle Drawing Functions</b><p>
<b></b><p>
<b></b><p>
<b>Optimize Drawing</b><p>
<b></b><p>
<b></b><p>
void<b> NSEraseRect(</b>NSRect <i>aRect</i>)	Erases the rectangle by filling it
with white. (This does not alter the current drawing color.)<p>
<p>
void <b>NSHighlightRect(</b>NSRect <i>aRect</i>)	Highlights or unhighlights a
rectangle by switching light gray for white and vice versa, when drawing on the
screen. If not drawing to the screen, the rectangle is filled with light
gray.<p>
<p>
void<b> NSRectClip(</b>NSRect <i>aRect</i>)	Intersects the current clipping
path with the rectangle <i>aRect</i>, to determine a new clipping path. <p>
<p>
void<b> NSRectClipList(</b>const NSRect *<i>rects</i>, 	Takes an array of
<i>count</i> number of rectangles and intersects <p>
int <i>count</i>)		the current clipping path with each of them. Thus, the new
clipping path is the graphic intersection of all the rectangles and the
original clipping path. <p>
<p>
void<b> NSRectFill(</b>NSRect <i>aRect</i>)	Fills the rectangle referred to by
<i>aRect</i> with the current color. <p>
<p>
void<b> NSRectFillList(</b>const NSRect *<i>rects</i>, <p>
int <i>count</i>)	Fills an array of <i>count</i> rectangles with the current
color.<p>
<p>
void<b> NSRectFillListWithGrays(</b>const NSRect *<i>rects</i>, <p>
const float *<i>grays</i>, int <i>count</i>)	Fills each rectangle in the array
<i>rects</i> with the gray whose value is stored at the corresponding location
in the array <i>grays</i>. Both arrays must be count elements long. Avoid
rectangles that overlap, because the order in which they'll be filled can't be
guaranteed. <p>
<b></b><p>
<b>Draw a Bordered Rectangle</b><p>
<b></b><p>
<b></b><p>
void <b>NSDrawButton(</b>NSRect <i>aRect</i>, 	Draws the bordered light gray
rectangle whose appearance<p>
NSRect <i>clipRect</i>)		signifies a button in the OpenStep user interface.
<i>aRect</i> is the bounds for the button, but only the area where <i>aRect</i>
intersects <i>clipRect</i> is drawn.<p>
<p>
void <b>NSDrawGrayBezel(</b>NSRect <i>aRect</i>, 	Draws a bordered light gray
rectangle with the appearance<p>
NSRect <i>clipRect</i>)		of a pushed-in button, clipped by intersecting with
<i>clipRect</i>.<p>
<p>
void<b> NSDrawGroove(</b>NSRect <i>aRect</i>, 	Draws a light gray rectangle
whose border is a groove, <p>
NSRect <i>clipRect</i>)		giving the appearance of a typical box in the OpenStep
user interface.<p>
<p>
NSRect <b>NSDrawTiledRects(</b>NSRect <i>boundsRect</i>, <b>	</b>Draws an
unfilled rectangle, clipped by <i>clipRect</i>, whose <p>
NSRect <i>clipRect</i>, <b> </b> 		border is defined by the parallel arrays
<i>sides</i> and <i>grays</i>,<p>
const NSRectEdge *<i>sides</i>,		both of length <i>count</i>. Each element of
<i>sides</i> specifies an<p>
const float *<i>grays</i>, <b>	<i>	</i></b>edge of the rectangle, which is
drawn with a width of<p>
int <i>count</i>)		1.0 using the corresponding gray level from <i>grays</i>. If
the <i>edges</i> array contains recurrences of the same edge, each is inset
within the previous edge.<p>
<p>
void <b>NSDrawWhiteBezel(</b>NSRect <i>aRect</i>, 	Draws a white rectangle with
a bezeled border. Only the<p>
NSRect <i>clipRect</i>)		area that intersects <i>clipRect</i> is drawn.<p>
<p>
void<b> NSFrameRect(</b>NSRect <i>aRect</i>)	Draws a frame of width 1.0 around
the inside of a rectangle, using the current color. <p>
<p>
void<b> NSFrameRectWithWidth(</b>NSRect <i>aRect</i>, 	Draws a frame of width
<i>frameWidth</i> around the inside of a<p>
float <i>frameWidth</i>)		rectangle, using the current color.<p>
<b></b><p>
<b>Color Functions</b><p>
<b></b><p>
<b></b><p>
<b>Get Information About Color Space and Window Depth</b><p>
<b></b><p>
<b></b><p>
const NSWindowDepth *<b>NSAvailableWindowDepths(</b>void<b>)</b> <p>
	Returns a zero-terminated list of available window depths.<p>
<p>
NSWindowDepth <b>NSBestDepth(</b>NSString *<i>colorSpace</i>, <p>
int <i>bitsPerSample</i>, int <i>bitsPerPixel</i>, 	Returns a window depth deep
enough for the given number <p>
BOOL <i>planar</i>, BOOL *<i>exactMatch</i>)		of colors, bits per sample, bits
per pixel, and if planar. Upon return, the variable pointed to by
<i>exactMatch</i> is YES if the window depth can accommodate all of the values
given for all of the parameters, NO if not.<p>
<p>
int <b>NSBitsPerPixelFromDepth(</b>NSWindowDepth <i>depth</i>) <p>
	Returns the number of bits per pixel for the given window depth.<p>
<b></b><p>
<b></b>int <b>NSBitsPerSampleFromDepth(</b>NSWindowDepth <i>depth</i>)<p>
	Returns the number of bits per sample (bits per pixel in each color component)
for the given window depth.<p>
<p>
NSString *<b>NSColorSpaceFromDepth(</b>NSWindowDepth <i>depth</i>)<p>
	Returns the name of the color space that matches the given window depth.<p>
<p>
int <b>NSNumberOfColorComponents(</b>NSString *<i>colorSpaceName</i>)<p>
	Returns the number of color components in the named color space.<p>
<p>
BOOL <b>NSPlanarFromDepth(</b>NSWindowDepth <i>depth</i>)<p>
	Returns YES if the given window depth is planar, NO if not.<p>
<b></b><p>
<b>Read the Color at a Screen Position</b><p>
<b></b><p>
<b></b><p>
NSColor <b>*NSReadPixel(</b>NSPoint <i>location</i>)	Returns the color of the
pixel at the given location, which must be specified in the current view's
coordinate system.<p>
<b></b><p>
<b>Text Functions</b><p>
<b></b><p>
<b></b><p>
<b>Filter Characters Entered into a Text Object</b><p>
<b></b><p>
<b></b><p>
unsigned short <b>NSEditorFilter(</b>unsigned short <i>theChar</i>, <p>
int <i>flags, </i>	Identical to <b>NSFieldFilter()</b> except that it passes on
values<p>
NSStringEncoding <i>theEncoding</i>) 		corresponding to Return, Tab, and
Shift-Tab directly to the NSText object.<p>
<p>
unsigned short <b>NSFieldFilter(</b>unsigned short <i>theChar</i>, <p>
int <i>flags</i>, 	Checks each character the user types into an NSText<p>
NSStringEncoding <i>theEncoding</i>)		object's text, allowing the user to move
the selection among text fields by pressing Return, Tab, or Shift-Tab.
Alphanumeric characters are passed to the NSText object for display. The
function returns either the ASCII value of the character typed, 0 (for illegal
characters or ones entered while a Command key is held down), or a constant
that the Text object interprets as a movement command.<p>
<b></b><p>
<b>Calculate or Draw a Line of Text (in Text Object)</b><p>
<b></b><p>
<b></b><p>
int <b>NSDrawALine(</b>id <i>self</i>, 	Draws a line of text, using the global
variables set by<p>
NSLayInfo *<i>layInfo</i>)		NSScanALine(). The return value has no
significance.<p>
<p>
int <b>NSScanALine(</b>id <i>self</i>, 	Determines the placement of characters
in a line of text. <i>self</i><p>
<i></i>NSLayInfo *<i>layInfo</i>)	<i>	 </i>refers to the NSText object calling
the function, and *<i>layInfo</i> is an NSLayInfo struct. The function returns
1 if a word's length exceeds the width of a line and the NSText's charWrap
instance variable is NO. Otherwise, it returns 0.<p>
<b></b><p>
<b>Calculate Font Ascender, Descender, and Line Height (in Text Object)</b><p>
<b></b><p>
<b></b><p>
void<b> NSTextFontInfo(</b>id <i>fid</i>, 	Calculates, and returns by
reference, the ascender,<p>
float *<i>ascender</i>, float *<i>descender</i>, 		descender, and line height
values for the NSFont given <p>
float *<i>lineHeight</i>)		by <i>font</i>.<p>
<b></b><p>
<b>Access Text Object's Word Tables</b><p>
<b></b><p>
<b></b><p>
NSData * <b>NSDataWithWordTable(</b>const<i> </i>unsigned char
*<i>smartLeft</i>, <p>
const unsigned char *<i>smartRight</i>, <b>	</b>Given pointers to word table
structures, records the<p>
const unsigned char *<i>charClasses</i>, 		structures in the returned NSData
object. The<p>
const NSFSM *<i>wrapBreaks</i>, 		arguments are similar to those of<p>
int <i>wrapBreaksCount</i>, <b>		NSReadWordTable()</b>.<p>
const NSFSM *<i>clickBreaks</i>, <p>
int <i>clickBreaksCount</i>, <p>
BOOL <i>charWrap</i>) <p>
<p>
void<b> NSReadWordTable(</b>NSZone<b> </b>*<i>zone</i>,<b> 	</b>Given
<i>data</i>, creates word tables in the memory zone<p>
NSData *<i>data</i>, 		specified by <i>zone</i>, returning (in the subsequent
<p>
unsigned char **<i>smartLeft</i>, 		arguments) pointers to the various tables.
The integer<p>
unsigned char **<i>smartRight</i>, 		pointer arguments return the length of the
preceding<p>
unsigned char **<i>charClasses</i>, 		array, and <i>charWrap</i> indicates
whether words whose<p>
NSFSM **<i>wrapBreaks</i>, 		length exceeds the NSText object's line length
should <p>
int *<i>wrapBreaksCount</i>, 		be wrapped on a character-by-character basis.<p>
NSFSM **<i>clickBreaks</i>, <p>
int *<i>clickBreaksCount</i>, <p>
BOOL *<i>charWrap</i>)<p>
<p>
Array Allocation Functions for Use by the NSText Class<p>
<p>
NSTextChunk *<b>NSChunkCopy(</b>NSTextChunk *<i>pc</i>, 	Copies the array
<i>pc</i> to the array <i>dpc</i> and returns a pointer to<p>
NSTextChunk *<i>dpc</i>)		the copy. <p>
<p>
NSTextChunk <b>*NSChunkGrow(</b>NSTextChunk *<i>pc</i>, 	Increases the array
identified by the pointer <i>pc</i> to a size of<p>
int <i>newUsed</i>)	<i>	newUsed</i> bytes.<p>
<p>
NSTextChunk *<b>NSChunkMalloc(</b>int <i>growBy</i>, 	Allocates initial memory
for a structure whose first field is<p>
int <i>initUsed</i>)		an <b>NSTextChunk</b> structure and whose subsequent
field is a variable-sized array. The amount of memory allocated is equal to
<i>initUsed</i>. If <i>initUsed</i> is 0, <i>growBy</i> bytes are allocated.
<i>growBy</i> specifies how much memory should be allocated when the chunk
grows.<p>
<p>
NSTextChunk *<b>NSChunkRealloc(</b>NSTextChunk *<i>pc</i>)	<p>
<b>	</b>Increases the amount of memory available for the array identified by
the pointer <i>pc</i>, as determined by the array's NSTextChunk.<p>
<p>
NSTextChunk *<b>NSChunkZoneCopy(</b>NSTextChunk *<i>pc</i>, <p>
NSTextChunk *<i>dpc</i>, 	Like <b>NSChunkCopy()</b>, but uses the specified
zone of<p>
NSZone *<i>zone</i>)		memory.<p>
<p>
NSTextChunk *<b>NSChunkZoneGrow(</b>NSTextChunk *<i>pc</i>,<p>
int <i>newUsed</i>, 	Like <b>NSChunkGrow()</b>, but uses the specified zone
of<p>
NSZone *<i>zone</i>)		memory.<p>
<p>
NSTextChunk *<b>NSChunkZoneMalloc(</b>int <i>growBy</i>, 	Like
<b>NSChunkMalloc()</b>, but uses the specified zone of<p>
int <i>initUsed</i>, 		memory.<p>
NSZone *<i>zone</i>)<p>
<p>
NSTextChunk *<b>NSChunkZoneRealloc(</b>NSTextChunk *<i>pc</i>, <p>
NSZone *<i>zone</i>)	Like <b>NSChunkRealloc()</b>, but uses the specified zone
of memory.<p>
<b></b><p>
<b>Imaging Functions</b><p>
<b></b><p>
<b></b><p>
<b>Copy an image</b><p>
<b></b><p>
<b></b><p>
void <b>NSCopyBitmapFromGState(</b>int <i>srcGstate</i>, 	Copies the pixels in
the rectangle <i>srcRect</i> to the rectangle<p>
NSRect <i>srcRect</i>, 		<i>destRect</i>. The source rectangle is defined in
the <p>
NSRect<i> destRect</i>)	 	graphics state designated by <i>srcGstate</i>, and
the destination is defined in the current graphics state. <p>
<p>
void <b>NSCopyBits(</b>int <i>srcGstate</i>, 	Copies the pixels in the
rectangle <i>srcRect</i> to the location<p>
NSRect<i> srcRect</i>, 		<i>destPoint</i>. The source rectangle is defined in
the current<p>
NSPoint <i>destPoint</i>)		graphics state if <i>srcGstate</i> is NSNullObject;
otherwise, in the graphics state designated by <i>srcGstate</i>. The
<i>destPoint</i> destination is defined in the current graphics state.<p>
<b></b><p>
<b>Render Bitmap Images</b><p>
<b></b><p>
<b></b><p>
void <b>NSDrawBitmap</b>(NSRect <i>rect</i>,	Renders an image from a bitmap.
<i>rect</i> is the rectangle in<p>
int <i>pixelsWide</i>,		which the image is drawn, and <i>data </i>is the bitmap
data,<p>
int <i>pixelsHigh</i>,		stored in up to 5 channels unless <i>isPlanar </i>is NO
(in<p>
int <i>bitsPerSample</i>, 		which case the channels are interleaved in a single
<p>
int <i>samplesPerPixel</i>,		array).<p>
int <i>bitsPerPixel</i>,<p>
int <i>bytesPerRow</i>, <p>
BOOL <i>isPlanar</i>,<p>
BOOL <i>hasAlpha</i>, <p>
NSString *<i>colorSpaceName</i>, <p>
const unsigned char *const <i>data</i>[5]<b>)</b><p>
<b></b><p>
Attention Panel Functions<p>
<p>
<p>
Create an Attention Panel without Running It Yet<p>
<p>
<p>
id <b>NSGetAlertPanel(</b>NSString *<i>title</i>, 	Returns an NSPanel object
that you can use in a modal<p>
NSString *<i>msg</i>, <i>		</i>session. Unlike <b>NSRunAlertPanel()</b>, no
button is<p>
NSString *<i>defaultButton</i>, <i>		</i>displayed if <i>defaultButton</i> is
NULL.<p>
NSString *<i>alternateButton</i>, <p>
NSString *<i>otherButton, ...</i>)<p>
<p>
Create and Run an Attention Panel<p>
<p>
<p>
int <b>NSRunAlertPanel(</b>NSString *<i>title</i>, 	Creates an attention panel
that alerts the user to some<p>
NSString *<i>msg, 		</i>consequence of a requested action, and runs the panel
in<p>
NSString *<i>defaultButton, 		</i>a modal event loop. <i>title</i> is the
panel's title (by default, <p>
NSString *<i>alternateButton, 		</i>Alert);
<i>msg</i> is the <b>printf()</b>-style message that's<p>
NSString *<i>otherButton, ...</i>)		displayed in the panel;
<i>defaultButton</i> (by default, OK) is the
title for the main button, also activated by Return; <i>alternateButton</i> and
<i>otherButton</i> give two more choices, which are displayed only if the
corresponding argument isn't NULL. The trailing arguments are a variable number
of <b>printf()</b>-style arguments to msg.<p>
<p>
int <b>NSRunLocalizedAlertPanel(</b>NSString *<i>table</i>, 	Similar to
<b>NSRunAlertPanel()</b>, but preferred, as it makes<p>
NSString *<i>title</i>, 		use of OpenStep's localization feature for languages
of<p>
NSString *<i>msg, 	</i>	different countries.<p>
NSString *<i>defaultButton, </i><p>
<i></i>NSString *<i>alternateButton, </i><p>
<i></i>NSString *<i>otherButton, ...</i>)<p>
<p>
Release an Attention Panel<p>
<p>
<p>
void <b>NSReleaseAlertPanel(</b>id <i>panel</i>)	Releases the specified alert
panel.<p>
<b></b><p>
<b>Services Menu Functions</b><p>
<b></b><p>
<b></b><p>
<b>Determine Whether an Item Is Included in Services Menus</b><p>
<b></b><p>
<b></b><p>
int <b>NSSetShowsServicesMenuItem(</b>NSString *<i>item</i>, <p>
BOOL <i>sho</i>w<i>Service</i>)	Determines (based on the value of
<i>showService</i>) whether the <i>item</i> command will be included in other
applications' Services menus. <i>item</i> describes a service provided by this
application, and should be the same string entered in the Menu
Item: field of the services file. The function returns 0 upon
success.<p>
<p>
BOOL <b>NSShowsServicesMenuItem(</b>NSString *<i>item</i>)<p>
<b>	</b>Returns YES if item is currently shown in Services menus.<p>
<b></b><p>
<b>Programmatically Invoke a Service</b><p>
<b></b><p>
<b></b><p>
BOOL <b>NSPerformService(</b>NSString *<i>item</i>, 	Invokes a service found in
the application's Services menu.<p>
NSPasteboard *<i>pboard</i>)		 <i>item</i> is the name of a Services menu item,
in any language; a slash in this name represents a submenu. <i>pboard</i> must
contain the data required by the service, and when the function returns,
<i>pboard</i> will contain the data supplied by the service provider.<p>
<b></b><p>
<b>Force Services Menu to Update Based on New Services</b><p>
<b></b><p>
<b></b><p>
void <b>NSUpdateDynamicServices(</b>void<b>)	</b>Re-registers the services the
application is willing to provide, by reading the file with the extension
.service in the application path or in the
standard path for services.<p>
<b></b><p>
<b>Other Application Kit Functions</b><p>
<b></b><p>
<b></b><p>
<b>Play the System Beep</b><p>
<b></b><p>
<b></b><p>
void <b>NSBeep(</b>void<b>)	</b>Plays the system beep.<p>
<b></b><p>
<b>Return File-related Pasteboard Types</b><p>
<b></b><p>
<b></b><p>
NSString<b> </b>*<b>NSCreateFileContentsPboardType(</b>NSString
*<i>fileType</i>)<p>
	Returns a string naming a pasteboard type that represents a file's contents,
based on the supplied string <i>fileType</i>. <i>fileType</i> should generally
be the extension part of a file name. The conversion from a named file type to
a pasteboard type is simple; no mapping to standard pasteboard types is
attempted.<p>
<p>
NSString *<b>NSCreateFilenamePboardType(</b>NSString *<i>filename</i>)<p>
	Returns a string naming a pasteboard type that represents a a file name, based
on the supplied string <i>filename</i>. <p>
<p>
NSString *<b>NSGetFileType(</b>NSString *<i>pboardType</i>)	Returns the
extension or file name from which the pasteboard type <i>pboardType</i> was
derived. <b>nil</b> is returned if <i>pboardType</i> isn't a pasteboard type
created by <b>NSCreateFileContentsPboardType()</b> or
<b>NSCreateFilenamePboardType()</b>.<p>
<p>
NSArray *<b>NSGetFileTypes(</b>NSArray *<i>pboardTypes</i>)<p>
	Accepts an array of pasteboard types and returns an array of the unique
extensions and file names from the file-content and file-name types found in
the input array. It returns <b>nil</b> if the input array contains no
file-content or file-name types.<p>
<b></b><p>
<b>Draw a Distinctive Outline around Linked Data</b><p>
<b></b><p>
<b></b><p>
void<b> NSFrameLinkRect(</b>NSRect <i>aRect</i>, 	Draws a distinctive link
outline just outside the rectangle<p>
BOOL <i>isDestination</i>)	<i>	aRect</i>. To draw an outline around a
destination link, <i>isDestination</i> should be YES, otherwise NO. <p>
<p>
float <b>NSLinkFrameThickness(</b>void<b>)</b>	Returns the thickness of the
link outline so that the outline can be properly erased by the application, or
for other purposes.<p>
<b></b><p>
<b>Convert an Event Mask Type to a Mask</b><p>
<b></b><p>
<b></b><p>
unsigned int <b>NSEventMaskFromType</b>(NSEventType <i>type</i>)<p>
	Returns the event mask corresponding to <i>type</i> (which is an enumeration
constant). The returned mask equals 1 left-shifted by <i>type </i>bits. <p>
</body></html>
