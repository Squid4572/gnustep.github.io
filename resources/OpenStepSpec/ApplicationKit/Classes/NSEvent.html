<html><head><TITLE>NSEvent.html</TITLE>
<!-- This document was created from RTF source by rtftohtml version 2.7.4,
     extended by rtftoweb version 1.4. -->
</head><body><A HREF="index.html">Return to the Alphabetic Index</A><br><A HREF="browser.html">Return to the Class Browser</A><br><A HREF="pic_browser.html">Return to the Picture Browser</A><HR>
Copyright (c) 1994 by NeXT Computer, Inc.  All Rights
Reserved.<p>
<p>

<b>NSEvent </b><p>

<B>Inherits From: </B><A HREF="NSObject.html">NSObject</A><p>
<p>
<b>Conforms To:	</b>NSCoding, NSCopying
NSObject (NSObject)<p>
<p>
<b>Declared In:	</b>AppKit/NSEvent.h <p>
<p>

<b>Class Description</b><p>


An NSEvent object contains information about an event such as a mouse-click or
a key-down. The window system  associates each such user action with a window,
reporting the event to the application that created the window. Pertinent
information about each eventsuch as which character was typed and where
the mouse was locatedis collected in an NSEvent object and made
available to the application. As events are received in the application,
they're temporarily placed in storage called the event queue. When the
application is ready to process an event, it takes an NSEvent from the queue.
<p>
<p>
NSEvents are typically passed to the responder chaina set of objects
within the window that inherit from NSResponder. For example, NSResponder's
<b>mouseDown:</b> and <b>keyDown:</b> methods take an NSEvent as an argument.
When an NSApplication retrieves an NSEvent from the event queue, it dispatches
it to the appropriate NSWindow (which is itself an NSResponder) by invoking
<b>keyDown:</b> or a similar message. The NSWindow in turn passes the event to
the first responder, and the event gets passed on down the responder chain
until some object handles it. In the case of a mouse-down, a <b>mouseDown:</b>
message is sent to the NSView in which the user clicked the mouse, which relays
the message to its next responder if it can't handle the message itself.<p>
<p>
Most events follow this same path: from the window system to the application's
event queue, and from there, to the appropriate objects of the application.
However, the Application Kit can create an NSEvent from scratch and insert it
into the event queue for distribution, or send it directly to its destination.
(It's rare for an <i>application</i> to create an event directly, but it's
possible, using NSEvent class methods. The newly created events can be added to
the event queue by invoking NSWindow's (or NSApplication's)
<b>postEvent:atStart:</b> method.<p>
<p>
Events are retrieved from the event queue by calling the NSWindow method<b>
nextEventMatchingMask:untilDate:inMode:dequeue:</b> or a similar NSApplication
method. These methods return an instance of NSEvent. The nature of the
retrieved event can then be ascertained by invoking NSEvent instance
methods<b>type</b>, <b>window</b>, and so forth. All types of events are
associated with a window. The corresponding NSWindow object can be gotten by
invoking <b>window</b>. The location of the event within the window's
coordinate system is obtained from <b>locationInWindow</b>, and the time of the
event is gotten from <b>timestamp</b>. The <b>modifierFlags</b> method returns
an indication of which modifier keys (Command, Control, Shift, and so forth)
were held down while the event occurred. <p>
<p>
The <b>type </b>method returns an NSEventType, a constant that identifies the
sort of event. The different types of events fall into five groups:<p>
<p>
.	Keyboard events<p>
<p>
.	Mouse events<p>
<p>
.	Tracking-rectangle events<p>
<p>
.	Periodic events<p>
<p>
.	Cursor-update events <p>
<p>
Some of these groups comprise several NSEventType constants; others only one.
The following sections discuss the groups, along with the corresponding
NSEventType constants.<p>
<p>

<b>Keyboard Events</b><p>

Among the most common events sent to an application are direct reports of the
user's keyboard actions, identified by these three NSEventType constants:<p>
<p>
.	NSKeyDown: The user generated a character by pressing a key.<p>
<p>
.	NSKeyUp: The key was released.<p>
<p>
.	NSFlagsChanged: The user pressed or released a modifier key, or turned Alpha
Lock on or off<i>. </i><p>
<i></i><p>
<i></i>Of these, key-down events are the most useful to the application. When
the <b>type </b>method returns NSKeyDown, your next step is typically to
determine the character or characters generated by the key-down, by sending the
NSEvent a <b>characters</b> message. <p>
<p>
Key-up events are less used since they follow almost automatically when there
has been a key-down event. And because NSEvent's<b> modifierFlags</b> method
returns the state of the modifier keys regardless of the type of event,
applications normally don't need to receive flags-changed events; they're
useful only for applications that have to keep track of the state of these keys
continuously.<p>
<p>

<b>Mouse Events</b><p>

Mouse events are generated by changes in the state of the mouse buttons and by
changes in the position of the mouse cursor on the screen. This category
consists of:<p>
<p>
.	NSLeftMouseDown, NSLeftMouseUp, NSRightMouseDown, NSRightMouseUp: Two sets of
mouse-down and mouse-up events, one for the left mouse button and one for the
right. Mouse-down means the user pressed the
button; mouse-up means the button was released.
If the mouse has just one button, only left mouse events are generated. By
sending a <b>clickCount </b>message to the NSEvent, you can determine whether
the mouse event was a single-click, double-click, and so on.<p>
<p>
.	NSLeftMouseDragged, NSRightMouseDragged: Two types of mouse-dragged
eventsone for when the mouse is moved with its left mouse button down,
or with both buttons down, and one for when it's moved with just the right
button down. A mouse with a single button generates only left mouse-dragged
events. As the mouse is moved with a button down, a series of mouse-dragged
events is produced. The series is always preceded by a mouse-down event and
followed by a mouse-up event.<p>
<p>
.	NSMouseMoved: The user moved the mouse without holding down either mouse
button.<p>
<p>
Mouse-dragged and mouse-moved events are generated repeatedly as long as the
user keeps moving the mouse. If the user holds the mouse stationary, neither
event is generated until it moves again. <p>
<p>
<b>Note:  </b>OpenStep doesn't specify facilities for the third button of a
three-button mouse. <p>
<p>

<b>Tracking-Rectangle Events</b><p>

NSMouseEntered and NSMouseExited events are like the Mouse
Events listed previously, in that they're dependent on mouse
movements. However, unlike the others, they're generated only if the
application has asked the window system to set a tracking rectangle in a
window. An NSMouseEntered or NSMouseExited event is created when the cursor has
entered the tracking rectangle or left it. A window can have any number of
tracking rectangles; the NSEvent method <b>trackingNumber</b> identifies which
rectangle was entered or exited.<p>
<p>

<b>Periodic Events</b><p>

An event of type NSPeriodic simply notifies an application that a certain time
interval has elapsed. By using the NSEvent class method
<b>startPeriodicEventsAfterDelay:withPeriod:</b>, an application can register
that it wants periodic events and that they should be placed in its event queue
at a certain frequency. When the application no longer needs them, the flow of
periodic events can be turned off by invoking <b>stopPeriodicEvents</b>. An
application can't have more than one stream of periodic events active at a
time.<i> </i>Unlike keyboard and mouse events, periodic events aren't
dispatched to an NSWindow.<p>
<p>

<b>Cursor-Update Events<i> </i></b><p>
<b><i></i></b><p>
Events of type NSCursorUpdate are used to implement NSView's cursor-rectangle
methods. An NSCursorUpdate event is generated when the cursor has crossed the
boundary of a predefined rectangular area. The application can respond by
updating the cursor's shape. <p>
<p>

<b>Creating NSEvent Objects </b><p>

<UL><LI> + (NSEvent *)<b>enterExitEventWithType:</b>(NSEventType)<i>type</i>	
<b>location:</b>(NSPoint)<i>location</i>	Returns an NSEvent object initialized
with general event
<b>modifierFlags:</b>(unsigned int)<i>flags</i>		data and information specific
to mouse tracking
<b>timestamp:</b>(NSTimeInterval)<i>time</i>		(<i>eventNum,</i>
<i>trackingNum,</i> <i>userData)</i>.
<b>windowNumber:</b>(int)<i>windowNum</i>	
<b>context:</b>(NSDPSContext *)<i>context</i>	
<b>eventNumber:</b>(int)<i>eventNum</i>	
<b>trackingNumber:</b>(int)<i>trackingNum</i>	
<b>userData:</b>(void *)<i>userData</i>	 
</LI><LI> +  (NSEvent *)<b>keyEventWithType:</b>(NSEventType)<i>type</i>	
<b>location:</b>(NSPoint)<i>location</i>	Returns an NSEvent object initialized
with general event
<b>modifierFlags:</b>(unsigned int)<i>flags</i>		data and information specific
to keyboard events (<i>keys,</i>
<i></i><b>timestamp:</b>(NSTimeInterval)<i>time</i>		<i>repeatKey,</i>
<i>code</i>, <i>ukeys</i>). (<i>ukeys</i> sets the unmodified 
<b>windowNumber:</b>(int)<i>windowNum</i>		character string.)
<b>context:</b>(NSDPSContext *)<i>context</i>	
<b>characters:</b>(NSString *)<i>keys</i>	
<b>charactersIgnoringModifiers:</b>(NSString *)<i>ukeys</i>
<i></i><b>isARepeat:</b>(BOOL)<i>repeatKey</i>	
<b>keyCode:</b>(unsigned short)<i>code</i>	 
</LI><LI> +  (NSEvent *)<b>mouseEventWithType:</b>(NSEventType)<i>type</i>	
<b>location:</b>(NSPoint)<i>location</i>	Returns an NSEvent object initialized
with general event
<b>modifierFlags:</b>(unsigned int)<i>flags</i>		data and information specific
to mouse events 
<b>timestamp:</b>(NSTimeInterval)<i>time</i>		(<i>eventNum, clickNum,</i>
<i>pressureValue)</i>.
<b>windowNumber:</b>(int)<i>windowNum</i>	
<b>context:</b>(NSDPSContext *)<i>context</i>	
<b>eventNumber:</b>(int)<i>eventNum</i>	
<b>clickCount:</b>(int)<i>clickNum</i>	
<b>pressure:</b>(float)<i>pressureValue</i>	 
</LI><LI> +  (NSEvent *)<b>otherEventWithType:</b>(NSEventType)<i>type</i>	
<b>location:</b>(NSPoint)<i>location</i>	Returns an NSEvent object initialized
with general event
<b>modifierFlags:</b>(unsigned int)<i>flags</i>		data and information specific
to kit-defined events
<b>timestamp:</b>(NSTimeInterval)<i>time</i>		(<i>subType,</i> <i>data1,</i>
<i>data2)</i>.
<b>windowNumber:</b>(int)<i>windowNum</i>	
<b>context:</b>(NSDPSContext *)<i>context</i>	
<b>subtype:</b>(short)<i>subType</i>	
<b>data1:</b>(int)<i>data1</i>	
<b>data2:</b>(int)<i>data2</i>	 </LI></UL>
<b>Getting General Event Information</b><p>

<UL><LI> - (NSDPSContext *)<b>context</b>	Returns the Display PostScript context of the
event.
</LI><LI> -  (NSPoint)<b>locationInWindow</b>	Returns the event's location in the base
coordinate system of its window.
</LI><LI> -  (unsigned int)<b>modifierFlags</b>	Returns an integer bitfield containing
modifier-key flags.
</LI><LI> -  (NSTimeInterval)<b>timestamp</b>	Returns the time the event occurred in
seconds since system startup.
</LI><LI> -  (NSEventType)<b>type</b>	Returns the type of the event (left-mouse-up,
right-mouse-dragged, key-down, etc.).
</LI><LI> -  (NSWindow *)<b>window</b>	Returns the window object associated with the
event.
</LI><LI> -  (int)<b>windowNumber</b>	Returns the number of the window associated with the
event.</LI></UL>
<b>Getting Key Event Information</b><p>

<UL><LI> - (NSString *)<b>characters</b>	Returns the character code (a string of
characters generated by the key event).
</LI><LI> -  (NSString *)<b>charactersIgnoringModifiers</b>	Returns the string of
characters generated by the key event as if no modifier key had been pressed
(except for Shift).
</LI><LI> -  (BOOL)<b>isARepeat</b>	Returns whether the key event is being repeated (user
is holding down the key).
</LI><LI> -  (unsigned short)<b>keyCode</b>	Returns the code that maps to a key on the
keyboard.</LI></UL>
<b>Getting Mouse Event Information</b><p>

<UL><LI> - (int)<b>clickCount</b>	Returns the number of mouse clicks associated with the
mouse event.
</LI><LI> -  (int)<b>eventNumber</b>	Returns the event number of the latest mouse-down
event. This information is also useful for handling tracking events.
</LI><LI> -  (float)<b>pressure</b>	Returns a value indicating the pressure applied to the
input device (used for appropriate devices, not mice).</LI></UL>
<b>Getting Tracking Event Information</b><p>

<UL><LI> - (int)<b>trackingNumber</b>	Returns the number that identifies the tracking
rectangle.
</LI><LI> -  (void *)<b>userData</b>	Returns data arbitrarily associated with the event.</LI></UL>
<b>Requesting Periodic Events</b><p>


+
(void)<b>startPeriodicEventsAfterDelay:</b>(NSTimeInterval)<i>delaySeconds</i><p
<i></i><b>withPeriod:</b>(NSTimeInterval)<i>periodSeconds	</i>Start generating
periodic events with frequency <i>periodSeconds</i> after delay<i>
delaySeconds</i> for current thread.<p>
<p>
+ (void)<b>stopPeriodicEvents	</b>Stop generating periodic events for current
thread, and discard any periodic events remaining in the queue. <p>

<b>Getting Information about Specially Defined Events</b><p>

<UL><LI> - (int)<b>data1</b>	Returns special data associated with the event.
</LI><LI> -  (int)<b>data2</b>	Returns special data associated with the event.
</LI><LI> -  (short)<b>subtype</b>	Returns the identifier of the specially defined
event.
</body></html>