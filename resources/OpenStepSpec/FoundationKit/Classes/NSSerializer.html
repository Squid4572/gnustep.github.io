<html><head><TITLE>NSSerializer.html</TITLE>
<!-- This document was created from RTF source by rtftohtml version 2.7.4,
     extended by rtftoweb version 1.4. -->
</head><body><A HREF="index.html">Return to the Alphabetic Index</A><br><A HREF="browser.html">Return to the Class Browser</A><br><A HREF="pic_browser.html">Return to the Picture Browser</A><HR>
Copyright (c) 1994 by NeXT Computer, Inc.  All Rights
Reserved.<p>
<p>

<b>NSSerializer </b><p>

<B>Inherits From: </B><A HREF="NSObject.html">NSObject</A><p>
<p>
<b>Conforms To:	</b>NSObject (NSObject)
<p>
<b>Declared In:	</b>Foundation/NSSerialization.h <p>
<p>

<b>Class Description</b><p>


The NSSerializer class provides a mechanism for creating an abstract
representation of a property list. (In OpenStep, property lists are defined to
beand to containobjects of these classes: NSDictionary, NSArray,
NSString, NSData). The NSSerializer class stores this representation in an
NSData object in an architecture-independent format, so that property lists can
be used with distributed applications. NSSerializer's companion class
NSDeserializer declares methods that take the abstract representation and
recreate the property list in memory.<p>
<p>
In contrast to archiving (see the NSArchiver class specification), the
serialization process preserves only structural information, not class
information. Thus, if a property list is serialized and then deserialized, the
objects in the resulting property list might not be of the same class as the
objects in the original property list. However, the structure and
interrelationships of the data in the resulting property list are identical to
that in the original, with one possible exception.<p>
<p>
The exception is that when an object graph is serialized, the mutability of the
containers objects (NSDictionary and NSArray objects) is preserved only down to
the highest node in the graph that has an immutable container. Thus, if an
NSArray contains an NSMutableDictionary, the serialized version of this object
graph would not preserve the mutability of the dictionary or any of the mutable
objects it contained. Since serialization doesn't preserve class information
orin some casesmutability, coding (as implemented by NSCoder and
NSArchiver) is the preferred way to make object graphs persistent.<p>
<p>
The NSSerializer class object provides the interface to the serialization
process; you don't create instances of NSSerializer. You might subclass
NSSerializer to modify the representation it creates, for example, to encrypt
the data or add authentication information.<p>
<p>
Other types of data besides property lists can be serialized using methods
declared by the NSData and NSMutableData classes (see
<b>serializeDataAt:ofObjCType:context:</b> and
<b>deserializeDataAt:ofObjCType:atCursor:context:</b>), allowing these types to
be represented in an architecture-independent format. Furthermore, the
NSObjCTypeSerializationCallBack protocol allows you to serialize and
deserialize objects that aren't property lists.<p>
<p>

<b>Serialization of Property Lists </b><p>

<UL><LI> + (NSData *)<b>serializePropertyList:</b>(id)<i>aPropertyList</i>
<i></i>	Creates a data object, serializes <i>aPropertyList</i> into it, and
returns the data object. <i>aPropertyList</i> must be a kind of NSData,
NSString, NSArray, or NSDictionary. 
</LI><LI> +  (void)<b>serializePropertyList:</b>(id)<i>aPropertyList</i>	Serializes the
property list <i>aPropertyList</i> in the mutable 
<b>intoData:</b>(NSMutableData *)<i>mdata</i>	<i>	</i>data object<i> mdata</i>.
<i>aPropertyList</i> must be a kind of NSData, NSString, NSArray, or
NSDictionary.
</body></html>